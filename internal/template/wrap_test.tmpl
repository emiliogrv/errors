{{if .WithGenHeader -}}
// Code generated by errors_generator; DO NOT EDIT.
// Generated at {{.Date}}
// Version {{.Version}}

{{end -}}
package {{.PackageName}}

import (
	stderrors "errors"
	"fmt"
	"io"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Custom error types for testing.
type customError struct {
	msg string
}

func (e *customError) Error() string {
	return e.msg
}

type customErrorWithIs struct {
	target error
	msg    string
}

func (e *customErrorWithIs) Error() string {
	return e.msg
}

func (e *customErrorWithIs) Is(target error) bool {
	return e.target == target
}

type customErrorWithAs struct {
	msg   string
	value int
}

func (e *customErrorWithAs) Error() string {
	return e.msg
}

func (e *customErrorWithAs) As(target any) bool {
	if t, ok := target.(*customErrorWithAs); ok {
		*t = *e

		return true
	}

	return false
}

func TestUnwrap(t *testing.T) {
	baseErr := stderrors.New("base error")
	wrappedErr := fmt.Errorf("wrapped: %w", baseErr)

	t.Parallel()

	tests := []struct {
		err       error
		wantErr   error
		name      string
		wantIsNil bool
	}{
		{
			name:      "given_nil_error_when_unwrap_then_returns_nil",
			err:       nil,
			wantErr:   nil,
			wantIsNil: true,
		},
		{
			name:      "given_unwrapped_error_when_unwrap_then_returns_nil",
			err:       stderrors.New("simple error"),
			wantErr:   nil,
			wantIsNil: true,
		},
		{
			name:      "given_wrapped_error_when_unwrap_then_returns_base_error",
			err:       wrappedErr,
			wantErr:   baseErr,
			wantIsNil: false,
		},
		{
			name:      "given_structured_error_when_unwrap_then_returns_nil",
			err:       New("structured"),
			wantErr:   nil,
			wantIsNil: true,
		},
		{
			name:      "given_custom_error_when_unwrap_then_returns_nil",
			err:       &customError{msg: "custom"},
			wantErr:   nil,
			wantIsNil: true,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := Unwrap(test.err)

				// then
				if test.wantIsNil {
					require.NoError(t, got)
				} else {
					assert.Equal(t, test.wantErr, got)
				}
			},
		)
	}
}

func TestUnwrapWithMultipleLevels(t *testing.T) {
	t.Parallel()

	tests := []struct {
		err             error
		name            string
		wantUnwrapCount int
	}{
		{
			name:            "given_single_wrap_when_unwrap_then_one_level",
			err:             fmt.Errorf("wrap1: %w", stderrors.New("base")),
			wantUnwrapCount: 1,
		},
		{
			name:            "given_double_wrap_when_unwrap_then_two_levels",
			err:             fmt.Errorf("wrap2: %w", fmt.Errorf("wrap1: %w", stderrors.New("base"))),
			wantUnwrapCount: 2,
		},
		{
			name: "given_triple_wrap_when_unwrap_then_three_levels",
			err: fmt.Errorf(
				"wrap3: %w",
				fmt.Errorf("wrap2: %w", fmt.Errorf("wrap1: %w", stderrors.New("base"))),
			),
			wantUnwrapCount: 3,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				current := test.err
				count := 0

				for current != nil {
					current = Unwrap(current)
					if current != nil {
						count++
					}
				}

				// then
				assert.Equal(t, test.wantUnwrapCount, count)
			},
		)
	}
}

func TestIs(t *testing.T) {
	baseErr := stderrors.New("base error")
	wrappedErr := fmt.Errorf("wrapped: %w", baseErr)
	otherErr := stderrors.New("other error")

	t.Parallel()

	tests := []struct {
		err    error
		target error
		name   string
		want   bool
	}{
		{
			name:   "given_nil_error_when_is_then_returns_false",
			err:    nil,
			target: baseErr,
			want:   false,
		},
		{
			name:   "given_same_error_when_is_then_returns_true",
			err:    baseErr,
			target: baseErr,
			want:   true,
		},
		{
			name:   "given_wrapped_error_when_is_with_base_then_returns_true",
			err:    wrappedErr,
			target: baseErr,
			want:   true,
		},
		{
			name:   "given_wrapped_error_when_is_with_other_then_returns_false",
			err:    wrappedErr,
			target: otherErr,
			want:   false,
		},
		{
			name:   "given_different_error_when_is_then_returns_false",
			err:    baseErr,
			target: otherErr,
			want:   false,
		},
		{
			name:   "given_nil_target_when_is_then_returns_false",
			err:    baseErr,
			target: nil,
			want:   false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := Is(test.err, test.target)

				// then
				assert.Equal(t, test.want, got)
			},
		)
	}
}

func TestIsWithStructuredError(t *testing.T) {
	baseErr := stderrors.New("base error")
	structuredErr := New("structured").WithErrors(baseErr)

	t.Parallel()

	tests := []struct {
		err    error
		target error
		name   string
		want   bool
	}{
		{
			name:   "given_structured_error_when_is_with_self_then_returns_true",
			err:    structuredErr,
			target: structuredErr,
			want:   true,
		},
		{
			name:   "given_structured_error_when_is_with_child_then_returns_true",
			err:    structuredErr,
			target: baseErr,
			want:   true,
		},
		{
			name:   "given_structured_error_when_is_with_other_then_returns_false",
			err:    structuredErr,
			target: stderrors.New("other"),
			want:   false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := Is(test.err, test.target)

				// then
				assert.Equal(t, test.want, got)
			},
		)
	}
}

func TestIsWithCustomIsMethod(t *testing.T) {
	targetErr := stderrors.New("target error")
	customErr := &customErrorWithIs{msg: "custom", target: targetErr}

	t.Parallel()

	tests := []struct {
		err    error
		target error
		name   string
		want   bool
	}{
		{
			name:   "given_custom_error_with_is_when_is_with_target_then_returns_true",
			err:    customErr,
			target: targetErr,
			want:   true,
		},
		{
			name:   "given_custom_error_with_is_when_is_with_other_then_returns_false",
			err:    customErr,
			target: stderrors.New("other"),
			want:   false,
		},
		{
			name:   "given_wrapped_custom_error_when_is_with_target_then_returns_true",
			err:    fmt.Errorf("wrapped: %w", customErr),
			target: targetErr,
			want:   true,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := Is(test.err, test.target)

				// then
				assert.Equal(t, test.want, got)
			},
		)
	}
}

func TestIsWithSentinelErrors(t *testing.T) {
	t.Parallel()

	tests := []struct {
		err    error
		target error
		name   string
		want   bool
	}{
		{
			name:   "given_eof_error_when_is_with_eof_then_returns_true",
			err:    io.EOF,
			target: io.EOF,
			want:   true,
		},
		{
			name:   "given_wrapped_eof_when_is_with_eof_then_returns_true",
			err:    fmt.Errorf("read failed: %w", io.EOF),
			target: io.EOF,
			want:   true,
		},
		{
			name:   "given_unexpected_eof_when_is_with_eof_then_returns_false",
			err:    io.ErrUnexpectedEOF,
			target: io.EOF,
			want:   false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := Is(test.err, test.target)

				// then
				assert.Equal(t, test.want, got)
			},
		)
	}
}

func TestAs(t *testing.T) {
	customErr := &customError{msg: "custom error"}
	wrappedCustomErr := fmt.Errorf("wrapped: %w", customErr)

	t.Parallel()

	tests := []struct {
		err       error
		name      string
		wantMsg   string
		wantMatch bool
	}{
		{
			name:      "given_nil_error_when_as_then_returns_false",
			err:       nil,
			wantMatch: false,
			wantMsg:   "",
		},
		{
			name:      "given_custom_error_when_as_then_returns_true",
			err:       customErr,
			wantMatch: true,
			wantMsg:   "custom error",
		},
		{
			name:      "given_wrapped_custom_error_when_as_then_returns_true",
			err:       wrappedCustomErr,
			wantMatch: true,
			wantMsg:   "custom error",
		},
		{
			name:      "given_standard_error_when_as_with_custom_then_returns_false",
			err:       stderrors.New("standard"),
			wantMatch: false,
			wantMsg:   "",
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				var target *customError

				// when
				got := As(test.err, &target)

				// then
				assert.Equal(t, test.wantMatch, got)

				if test.wantMatch {
					assert.NotNil(t, target)
					assert.Equal(t, test.wantMsg, target.msg)
				} else {
					assert.Nil(t, target)
				}
			},
		)
	}
}

func TestAsWithStructuredError(t *testing.T) {
	structuredErr := New("structured error")
	wrappedStructured := fmt.Errorf("wrapped: %w", structuredErr)

	t.Parallel()

	tests := []struct {
		err         error
		name        string
		wantMessage string
		wantMatch   bool
	}{
		{
			name:        "given_structured_error_when_as_then_returns_true",
			err:         structuredErr,
			wantMatch:   true,
			wantMessage: "structured error",
		},
		{
			name:        "given_wrapped_structured_error_when_as_then_returns_true",
			err:         wrappedStructured,
			wantMatch:   true,
			wantMessage: "structured error",
		},
		{
			name:        "given_standard_error_when_as_with_structured_then_returns_false",
			err:         stderrors.New("standard"),
			wantMatch:   false,
			wantMessage: "",
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				var target *StructuredError

				// when
				got := As(test.err, &target)

				// then
				assert.Equal(t, test.wantMatch, got)

				if test.wantMatch {
					assert.NotNil(t, target)
					assert.Equal(t, test.wantMessage, target.Message)
				} else {
					assert.Nil(t, target)
				}
			},
		)
	}
}

func TestAsWithCustomAsMethod(t *testing.T) {
	customErr := &customErrorWithAs{msg: "custom", value: 42}
	wrappedCustomErr := fmt.Errorf("wrapped: %w", customErr)

	t.Parallel()

	tests := []struct {
		err       error
		name      string
		wantValue int
		wantMatch bool
	}{
		{
			name:      "given_custom_error_with_as_when_as_then_returns_true",
			err:       customErr,
			wantMatch: true,
			wantValue: 42,
		},
		{
			name:      "given_wrapped_custom_error_when_as_then_returns_true",
			err:       wrappedCustomErr,
			wantMatch: true,
			wantValue: 42,
		},
		{
			name:      "given_standard_error_when_as_with_custom_then_returns_false",
			err:       stderrors.New("standard"),
			wantMatch: false,
			wantValue: 0,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				var target *customErrorWithAs

				// when
				got := As(test.err, &target)

				// then
				assert.Equal(t, test.wantMatch, got)

				if test.wantMatch {
					assert.NotNil(t, target)
					assert.Equal(t, test.wantValue, target.value)
				} else {
					assert.Nil(t, target)
				}
			},
		)
	}
}

func TestAsWithMultipleLevels(t *testing.T) {
	customErr := &customError{msg: "base"}
	level1 := fmt.Errorf("level1: %w", customErr)
	level2 := fmt.Errorf("level2: %w", level1)
	level3 := fmt.Errorf("level3: %w", level2)

	t.Parallel()

	tests := []struct {
		err       error
		name      string
		wantMsg   string
		wantMatch bool
	}{
		{
			name:      "given_one_level_wrap_when_as_then_returns_true",
			err:       level1,
			wantMatch: true,
			wantMsg:   "base",
		},
		{
			name:      "given_two_level_wrap_when_as_then_returns_true",
			err:       level2,
			wantMatch: true,
			wantMsg:   "base",
		},
		{
			name:      "given_three_level_wrap_when_as_then_returns_true",
			err:       level3,
			wantMatch: true,
			wantMsg:   "base",
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				var target *customError

				// when
				got := As(test.err, &target)

				// then
				assert.Equal(t, test.wantMatch, got)

				if test.wantMatch {
					assert.NotNil(t, target)
					assert.Equal(t, test.wantMsg, target.msg)
				}
			},
		)
	}
}

func TestAsWithInterfaceTarget(t *testing.T) {
	customErr := &customError{msg: "custom"}
	wrappedCustomErr := fmt.Errorf("wrapped: %w", customErr)

	t.Parallel()

	tests := []struct {
		err       error
		name      string
		wantMatch bool
	}{
		{
			name:      "given_custom_error_when_as_with_error_interface_then_returns_true",
			err:       customErr,
			wantMatch: true,
		},
		{
			name:      "given_wrapped_custom_error_when_as_with_error_interface_then_returns_true",
			err:       wrappedCustomErr,
			wantMatch: true,
		},
		{
			name:      "given_nil_error_when_as_with_error_interface_then_returns_false",
			err:       nil,
			wantMatch: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				var target error

				// when
				got := As(test.err, &target)

				// then
				assert.Equal(t, test.wantMatch, got)

				if test.wantMatch {
					require.Error(t, target)
				} else {
					require.NoError(t, target)
				}
			},
		)
	}
}

func TestUnwrapIsAsIntegration(t *testing.T) {
	t.Parallel()

	tests := []struct {
		err             error
		name            string
		wantUnwrapNil   bool
		wantIsEOF       bool
		wantAsCustom    bool
		wantAsStructure bool
	}{
		{
			name:            "given_nil_error_when_unwrap_is_as_then_all_return_expected",
			err:             nil,
			wantUnwrapNil:   true,
			wantIsEOF:       false,
			wantAsCustom:    false,
			wantAsStructure: false,
		},
		{
			name:            "given_eof_error_when_unwrap_is_as_then_all_return_expected",
			err:             io.EOF,
			wantUnwrapNil:   true,
			wantIsEOF:       true,
			wantAsCustom:    false,
			wantAsStructure: false,
		},
		{
			name:            "given_wrapped_eof_when_unwrap_is_as_then_all_return_expected",
			err:             fmt.Errorf("wrapped: %w", io.EOF),
			wantUnwrapNil:   false,
			wantIsEOF:       true,
			wantAsCustom:    false,
			wantAsStructure: false,
		},
		{
			name:            "given_custom_error_when_unwrap_is_as_then_all_return_expected",
			err:             &customError{msg: "custom"},
			wantUnwrapNil:   true,
			wantIsEOF:       false,
			wantAsCustom:    true,
			wantAsStructure: false,
		},
		{
			name:            "given_structured_error_when_unwrap_is_as_then_all_return_expected",
			err:             New("structured"),
			wantUnwrapNil:   true,
			wantIsEOF:       false,
			wantAsCustom:    false,
			wantAsStructure: true,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				unwrapped := Unwrap(test.err)
				isEOF := Is(test.err, io.EOF)

				var customTarget *customError

				asCustom := As(test.err, &customTarget)

				var structuredTarget *StructuredError

				asStructured := As(test.err, &structuredTarget)

				// then
				if test.wantUnwrapNil {
					require.NoError(t, unwrapped)
				} else {
					require.Error(t, unwrapped)
				}

				assert.Equal(t, test.wantIsEOF, isEOF)
				assert.Equal(t, test.wantAsCustom, asCustom)
				assert.Equal(t, test.wantAsStructure, asStructured)
			},
		)
	}
}

func TestUnwrapWithJoinedErrors(t *testing.T) {
	err1 := stderrors.New("error1")
	err2 := stderrors.New("error2")
	joined := Join(err1, err2)

	t.Parallel()

	tests := []struct {
		err     error
		name    string
		wantNil bool
	}{
		{
			name:    "given_joined_errors_when_unwrap_then_returns_nil",
			err:     joined,
			wantNil: true,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := Unwrap(test.err)

				// then
				if test.wantNil {
					require.NoError(t, got)
				} else {
					require.Error(t, got)
				}
			},
		)
	}
}

func TestIsWithJoinedErrors(t *testing.T) {
	err1 := stderrors.New("error1")
	err2 := stderrors.New("error2")
	err3 := stderrors.New("error3")
	joined := Join(err1, err2)

	t.Parallel()

	tests := []struct {
		err    error
		target error
		name   string
		want   bool
	}{
		{
			name:   "given_joined_errors_when_is_with_first_then_returns_true",
			err:    joined,
			target: err1,
			want:   true,
		},
		{
			name:   "given_joined_errors_when_is_with_second_then_returns_true",
			err:    joined,
			target: err2,
			want:   true,
		},
		{
			name:   "given_joined_errors_when_is_with_other_then_returns_false",
			err:    joined,
			target: err3,
			want:   false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := Is(test.err, test.target)

				// then
				assert.Equal(t, test.want, got)
			},
		)
	}
}

func TestAsWithJoinedErrors(t *testing.T) {
	customErr := &customError{msg: "custom"}
	standardErr := stderrors.New("standard")
	joined := Join(customErr, standardErr)

	t.Parallel()

	tests := []struct {
		err       error
		name      string
		wantMsg   string
		wantMatch bool
	}{
		{
			name:      "given_joined_errors_with_custom_when_as_then_returns_true",
			err:       joined,
			wantMatch: true,
			wantMsg:   "custom",
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				var target *customError

				// when
				got := As(test.err, &target)

				// then
				assert.Equal(t, test.wantMatch, got)

				if test.wantMatch {
					assert.NotNil(t, target)
					assert.Equal(t, test.wantMsg, target.msg)
				}
			},
		)
	}
}

func TestStructuredErrorIs(t *testing.T) {
	baseErr := stderrors.New("base error")
	otherErr := stderrors.New("other error")
	structuredErr := New("structured")

	t.Parallel()

	tests := []struct {
		target   error
		receiver *StructuredError
		name     string
		want     bool
	}{
		{
			name:     "given_nil_receiver_when_is_then_returns_false",
			receiver: nil,
			target:   baseErr,
			want:     false,
		},
		{
			name:     "given_structured_error_when_is_with_self_then_returns_true",
			receiver: structuredErr,
			target:   structuredErr,
			want:     true,
		},
		{
			name:     "given_structured_error_when_is_with_different_then_returns_false",
			receiver: structuredErr,
			target:   baseErr,
			want:     false,
		},
		{
			name:     "given_structured_error_with_child_when_is_with_child_then_returns_true",
			receiver: New("parent").WithErrors(baseErr),
			target:   baseErr,
			want:     true,
		},
		{
			name:     "given_structured_error_with_child_when_is_with_other_then_returns_false",
			receiver: New("parent").WithErrors(baseErr),
			target:   otherErr,
			want:     false,
		},
		{
			name:     "given_structured_error_with_multiple_children_when_is_with_first_then_returns_true",
			receiver: New("parent").WithErrors(baseErr, otherErr),
			target:   baseErr,
			want:     true,
		},
		{
			name:     "given_structured_error_with_multiple_children_when_is_with_second_then_returns_true",
			receiver: New("parent").WithErrors(baseErr, otherErr),
			target:   otherErr,
			want:     true,
		},
		{
			name:     "given_structured_error_with_nested_children_when_is_with_deep_child_then_returns_true",
			receiver: New("parent").WithErrors(New("child").WithErrors(baseErr)),
			target:   baseErr,
			want:     true,
		},
		{
			name:     "given_structured_error_without_errors_when_is_with_other_then_returns_false",
			receiver: New("simple"),
			target:   baseErr,
			want:     false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.receiver.Is(test.target)

				// then
				assert.Equal(t, test.want, got)
			},
		)
	}
}

func TestStructuredErrorIsWithCustomErrors(t *testing.T) {
	targetErr := stderrors.New("target")
	customErr := &customErrorWithIs{msg: "custom", target: targetErr}

	t.Parallel()

	tests := []struct {
		target   error
		receiver *StructuredError
		name     string
		want     bool
	}{
		{
			name:     "given_structured_error_with_custom_child_when_is_with_target_then_returns_true",
			receiver: New("parent").WithErrors(customErr),
			target:   targetErr,
			want:     true,
		},
		{
			name:     "given_structured_error_with_custom_child_when_is_with_other_then_returns_false",
			receiver: New("parent").WithErrors(customErr),
			target:   stderrors.New("other"),
			want:     false,
		},
		{
			name:     "given_structured_error_with_wrapped_custom_when_is_with_target_then_returns_true",
			receiver: New("parent").WithErrors(fmt.Errorf("wrapped: %w", customErr)),
			target:   targetErr,
			want:     true,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.receiver.Is(test.target)

				// then
				assert.Equal(t, test.want, got)
			},
		)
	}
}

func TestStructuredErrorIsWithSentinelErrors(t *testing.T) {
	t.Parallel()

	tests := []struct {
		target   error
		receiver *StructuredError
		name     string
		want     bool
	}{
		{
			name:     "given_structured_error_with_eof_when_is_with_eof_then_returns_true",
			receiver: New("parent").WithErrors(io.EOF),
			target:   io.EOF,
			want:     true,
		},
		{
			name:     "given_structured_error_with_wrapped_eof_when_is_with_eof_then_returns_true",
			receiver: New("parent").WithErrors(fmt.Errorf("read failed: %w", io.EOF)),
			target:   io.EOF,
			want:     true,
		},
		{
			name:     "given_structured_error_with_unexpected_eof_when_is_with_eof_then_returns_false",
			receiver: New("parent").WithErrors(io.ErrUnexpectedEOF),
			target:   io.EOF,
			want:     false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.receiver.Is(test.target)

				// then
				assert.Equal(t, test.want, got)
			},
		)
	}
}

func TestStructuredErrorAs(t *testing.T) {
	customErr := &customError{msg: "custom error"}

	t.Parallel()

	tests := []struct {
		receiver  *StructuredError
		name      string
		wantMsg   string
		wantMatch bool
	}{
		{
			name:      "given_nil_receiver_when_as_then_returns_false",
			receiver:  nil,
			wantMatch: false,
			wantMsg:   "",
		},
		{
			name:      "given_structured_error_with_custom_child_when_as_with_custom_then_returns_true",
			receiver:  New("parent").WithErrors(customErr),
			wantMatch: true,
			wantMsg:   "custom error",
		},
		{
			name:      "given_structured_error_without_custom_when_as_with_custom_then_returns_false",
			receiver:  New("simple"),
			wantMatch: false,
			wantMsg:   "",
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				var target *customError

				// when
				got := test.receiver.As(&target)

				// then
				assert.Equal(t, test.wantMatch, got)

				if test.wantMatch && test.wantMsg != "" {
					assert.NotNil(t, target)
					assert.Equal(t, test.wantMsg, target.msg)
				}
			},
		)
	}
}

func TestStructuredErrorAsWithStructuredTarget(t *testing.T) {
	t.Parallel()

	tests := []struct {
		receiver    *StructuredError
		name        string
		wantMessage string
		wantMatch   bool
	}{
		{
			name:        "given_structured_error_when_as_with_structured_target_then_returns_true",
			receiver:    New("test message"),
			wantMatch:   true,
			wantMessage: "test message",
		},
		{
			name:        "given_structured_error_with_attrs_when_as_then_copies_all_fields",
			receiver:    New("test").WithAttrs(String("key", "value")),
			wantMatch:   true,
			wantMessage: "test",
		},
		{
			name:        "given_structured_error_with_tags_when_as_then_copies_all_fields",
			receiver:    New("test").WithTags("tag1", "tag2"),
			wantMatch:   true,
			wantMessage: "test",
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				target := &StructuredError{}

				// when
				got := test.receiver.As(target)

				// then
				assert.Equal(t, test.wantMatch, got)

				if test.wantMatch {
					assert.Equal(t, test.wantMessage, target.Message)
				}
			},
		)
	}
}

func TestStructuredErrorAsWithCustomAsMethod(t *testing.T) {
	customErr := &customErrorWithAs{msg: "custom", value: 42}

	t.Parallel()

	tests := []struct {
		receiver  *StructuredError
		name      string
		wantValue int
		wantMatch bool
	}{
		{
			name:      "given_structured_error_with_custom_child_when_as_then_returns_true",
			receiver:  New("parent").WithErrors(customErr),
			wantMatch: true,
			wantValue: 42,
		},
		{
			name:      "given_structured_error_with_wrapped_custom_when_as_then_returns_true",
			receiver:  New("parent").WithErrors(fmt.Errorf("wrapped: %w", customErr)),
			wantMatch: true,
			wantValue: 42,
		},
		{
			name:      "given_structured_error_without_custom_when_as_then_returns_false",
			receiver:  New("simple"),
			wantMatch: false,
			wantValue: 0,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				var target *customErrorWithAs

				// when
				got := test.receiver.As(&target)

				// then
				assert.Equal(t, test.wantMatch, got)

				if test.wantMatch {
					assert.NotNil(t, target)
					assert.Equal(t, test.wantValue, target.value)
				} else {
					assert.Nil(t, target)
				}
			},
		)
	}
}

func TestStructuredErrorAsWithMultipleLevels(t *testing.T) {
	customErr := &customError{msg: "base"}
	level1 := New("level1").WithErrors(customErr)
	level2 := New("level2").WithErrors(level1)
	level3 := New("level3").WithErrors(level2)

	t.Parallel()

	tests := []struct {
		receiver  *StructuredError
		name      string
		wantMsg   string
		wantMatch bool
	}{
		{
			name:      "given_one_level_nesting_when_as_then_returns_true",
			receiver:  level1,
			wantMatch: true,
			wantMsg:   "base",
		},
		{
			name:      "given_two_level_nesting_when_as_then_returns_true",
			receiver:  level2,
			wantMatch: true,
			wantMsg:   "base",
		},
		{
			name:      "given_three_level_nesting_when_as_then_returns_true",
			receiver:  level3,
			wantMatch: true,
			wantMsg:   "base",
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				var target *customError

				// when
				got := test.receiver.As(&target)

				// then
				assert.Equal(t, test.wantMatch, got)

				if test.wantMatch {
					assert.NotNil(t, target)
					assert.Equal(t, test.wantMsg, target.msg)
				}
			},
		)
	}
}

func TestStructuredErrorAsWithInterfaceTarget(t *testing.T) {
	customErr := &customError{msg: "custom"}

	t.Parallel()

	tests := []struct {
		receiver  *StructuredError
		name      string
		wantMatch bool
	}{
		{
			name:      "given_structured_error_with_custom_child_when_as_with_custom_then_finds_child",
			receiver:  New("parent").WithErrors(customErr),
			wantMatch: true,
		},
		{
			name:      "given_nil_receiver_when_as_with_custom_then_returns_false",
			receiver:  nil,
			wantMatch: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				var target *customError

				// when
				got := test.receiver.As(&target)

				// then
				assert.Equal(t, test.wantMatch, got)

				if test.wantMatch {
					assert.NotNil(t, target)
				} else {
					assert.Nil(t, target)
				}
			},
		)
	}
}

func TestStructuredErrorIsAsIntegration(t *testing.T) {
	baseErr := stderrors.New("base")
	customErr := &customError{msg: "custom"}
	targetErr := stderrors.New("target")
	customWithIs := &customErrorWithIs{msg: "custom_is", target: targetErr}

	t.Parallel()

	tests := []struct {
		receiver         *StructuredError
		name             string
		wantIsBase       bool
		wantIsTarget     bool
		wantAsCustom     bool
		wantAsStructured bool
	}{
		{
			name:             "given_simple_structured_error_when_is_as_then_returns_expected",
			receiver:         New("simple"),
			wantIsBase:       false,
			wantIsTarget:     false,
			wantAsCustom:     false,
			wantAsStructured: true,
		},
		{
			name:             "given_structured_with_base_when_is_as_then_returns_expected",
			receiver:         New("parent").WithErrors(baseErr),
			wantIsBase:       true,
			wantIsTarget:     false,
			wantAsCustom:     false,
			wantAsStructured: true,
		},
		{
			name:             "given_structured_with_custom_when_is_as_then_returns_expected",
			receiver:         New("parent").WithErrors(customErr),
			wantIsBase:       false,
			wantIsTarget:     false,
			wantAsCustom:     true,
			wantAsStructured: true,
		},
		{
			name:             "given_structured_with_custom_is_when_is_as_then_returns_expected",
			receiver:         New("parent").WithErrors(customWithIs),
			wantIsBase:       false,
			wantIsTarget:     true,
			wantAsCustom:     false,
			wantAsStructured: true,
		},
		{
			name:             "given_structured_with_multiple_children_when_is_as_then_returns_expected",
			receiver:         New("parent").WithErrors(baseErr, customErr),
			wantIsBase:       true,
			wantIsTarget:     false,
			wantAsCustom:     true,
			wantAsStructured: true,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				isBase := test.receiver.Is(baseErr)
				isTarget := test.receiver.Is(targetErr)

				var customTarget *customError

				asCustom := test.receiver.As(&customTarget)
				structuredTarget := &StructuredError{}
				asStructured := test.receiver.As(structuredTarget)

				// then
				assert.Equal(t, test.wantIsBase, isBase)
				assert.Equal(t, test.wantIsTarget, isTarget)
				assert.Equal(t, test.wantAsCustom, asCustom)
				assert.Equal(t, test.wantAsStructured, asStructured)
			},
		)
	}
}
