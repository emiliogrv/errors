{{if .WithGenHeader -}}
// Code generated by errors_generator; DO NOT EDIT.
// Generated at {{.Date}}
// Version {{.Version}}

{{end -}}
package {{.PackageName}}

import (
	stderrors "errors"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestNew(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		message string
		// then
		wantMessage string
		wantJoined  bool
	}{
		{
			name:        "given_non_empty_message_when_new_then_returns_structured_error_with_message",
			message:     "test error",
			wantMessage: "test error",
			wantJoined:  false,
		},
		{
			name:        "given_empty_message_when_new_then_returns_structured_error_with_empty_message",
			message:     "",
			wantMessage: "",
			wantJoined:  false,
		},
		{
			name:        "given_long_message_when_new_then_returns_structured_error_with_full_message",
			message:     "this is a very long error message that should be preserved completely",
			wantMessage: "this is a very long error message that should be preserved completely",
			wantJoined:  false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := New(test.message)

				// then
				assert.NotNil(t, got)
				assert.Equal(t, test.wantMessage, got.Message)
				assert.Equal(t, test.wantJoined, got.joined)
				assert.Empty(t, got.Attrs)
				assert.Empty(t, got.Errors)
				assert.Empty(t, got.Tags)
				assert.Empty(t, got.Stack)
			},
		)
	}
}

func TestStructuredErrorWithAttrs(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		initialError *StructuredError
		attrs        []Attr
		// then
		wantAttrsLen int
	}{
		{
			name:         "given_error_without_attrs_when_with_attrs_then_adds_attrs",
			initialError: New("test"),
			attrs:        []Attr{String("key", "value")},
			wantAttrsLen: 1,
		},
		{
			name:         "given_error_with_existing_attrs_when_with_attrs_then_replaces_attrs",
			initialError: New("test").WithAttrs(String("existing", "attr")),
			attrs:        []Attr{String("new", "attr")},
			wantAttrsLen: 1,
		},
		{
			name:         "given_error_when_with_multiple_attrs_then_adds_all_attrs",
			initialError: New("test"),
			attrs:        []Attr{String("key1", "value1"), Int("key2", 42)},
			wantAttrsLen: 2,
		},
		{
			name:         "given_error_when_with_empty_attrs_then_no_attrs_added",
			initialError: New("test"),
			attrs:        []Attr{},
			wantAttrsLen: 0,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.initialError.WithAttrs(test.attrs...)

				// then
				assert.NotNil(t, got)
				assert.Len(t, got.Attrs, test.wantAttrsLen)
				assert.Same(t, test.initialError, got) // Should return same instance
			},
		)
	}
}

func TestStructuredErrorWithTags(t *testing.T) {
	t.Parallel()

	tests := []struct {
		initialError *StructuredError
		name         string
		wantFirst    string
		tags         []string
		wantTagsLen  int
	}{
		{
			name:         "given_error_without_tags_when_with_tags_then_adds_tags",
			initialError: New("test"),
			tags:         []string{"tag1"},
			wantTagsLen:  1,
			wantFirst:    "tag1",
		},
		{
			name:         "given_error_with_existing_tags_when_with_tags_then_prepends_tags",
			initialError: New("test").WithTags("existing"),
			tags:         []string{"new"},
			wantTagsLen:  2,
			wantFirst:    "new",
		},
		{
			name:         "given_error_when_with_multiple_tags_then_adds_all_tags",
			initialError: New("test"),
			tags:         []string{"tag1", "tag2", "tag3"},
			wantTagsLen:  3,
			wantFirst:    "tag1",
		},
		{
			name:         "given_error_when_with_empty_tags_then_no_tags_added",
			initialError: New("test"),
			tags:         []string{},
			wantTagsLen:  0,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.initialError.WithTags(test.tags...)

				// then
				assert.NotNil(t, got)
				assert.Len(t, got.Tags, test.wantTagsLen)

				if test.wantTagsLen > 0 {
					assert.Equal(t, test.wantFirst, got.Tags[0])
				}

				assert.Same(t, test.initialError, got) // Should return same instance
			},
		)
	}
}

func TestStructuredErrorWithErrors(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		initialError *StructuredError
		errs         []error
		// then
		wantErrsLen int
	}{
		{
			name:         "given_error_without_errors_when_with_errors_then_adds_errors",
			initialError: New("test"),
			errs:         []error{stderrors.New("child error")},
			wantErrsLen:  1,
		},
		{
			name:         "given_error_with_existing_errors_when_with_errors_then_replaces_errors",
			initialError: New("test").WithErrors(stderrors.New("existing")),
			errs:         []error{stderrors.New("new")},
			wantErrsLen:  1,
		},
		{
			name:         "given_error_when_with_multiple_errors_then_adds_all_errors",
			initialError: New("test"),
			errs:         []error{stderrors.New("err1"), stderrors.New("err2"), stderrors.New("err3")},
			wantErrsLen:  3,
		},
		{
			name:         "given_error_when_with_nil_error_then_adds_nil",
			initialError: New("test"),
			errs:         []error{nil},
			wantErrsLen:  1,
		},
		{
			name:         "given_error_when_with_empty_errors_then_no_errors_added",
			initialError: New("test"),
			errs:         []error{},
			wantErrsLen:  0,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.initialError.WithErrors(test.errs...)

				// then
				assert.NotNil(t, got)
				assert.Len(t, got.Errors, test.wantErrsLen)
				assert.Same(t, test.initialError, got) // Should return same instance
			},
		)
	}
}

func TestStructuredErrorWithStack(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		initialError *StructuredError
		stack        []byte
		// then
		wantStack []byte
	}{
		{
			name:         "given_error_without_stack_when_with_stack_then_adds_stack",
			initialError: New("test"),
			stack:        []byte("stack trace line 1\nstack trace line 2"),
			wantStack:    []byte("stack trace line 1\nstack trace line 2"),
		},
		{
			name:         "given_error_with_existing_stack_when_with_stack_then_replaces_stack",
			initialError: New("test").WithStack([]byte("old stack")),
			stack:        []byte("new stack"),
			wantStack:    []byte("new stack"),
		},
		{
			name:         "given_error_when_with_empty_stack_then_sets_empty_stack",
			initialError: New("test"),
			stack:        []byte{},
			wantStack:    []byte{},
		},
		{
			name:         "given_error_when_with_nil_stack_then_sets_nil_stack",
			initialError: New("test"),
			stack:        nil,
			wantStack:    nil,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.initialError.WithStack(test.stack)

				// then
				assert.NotNil(t, got)
				assert.Equal(t, test.wantStack, got.Stack)
				assert.Same(t, test.initialError, got) // Should return same instance
			},
		)
	}
}

func TestStructuredErrorAppendErrors(t *testing.T) {
	t.Parallel()

	tests := []struct {
		initialError *StructuredError
		name         string
		wantLast     string
		errs         []error
		wantErrsLen  int
	}{
		{
			name:         "given_error_without_errors_when_append_errors_then_adds_errors",
			initialError: New("test"),
			errs:         []error{stderrors.New("appended")},
			wantErrsLen:  1,
			wantLast:     "appended",
		},
		{
			name:         "given_error_with_existing_errors_when_append_errors_then_appends_to_end",
			initialError: New("test").WithErrors(stderrors.New("first")),
			errs:         []error{stderrors.New("last")},
			wantErrsLen:  2,
			wantLast:     "last",
		},
		{
			name:         "given_error_when_append_multiple_errors_then_adds_all_to_end",
			initialError: New("test").WithErrors(stderrors.New("first")),
			errs:         []error{stderrors.New("second"), stderrors.New("third")},
			wantErrsLen:  3,
			wantLast:     "third",
		},
		{
			name:         "given_error_when_append_empty_errors_then_no_change",
			initialError: New("test").WithErrors(stderrors.New("only")),
			errs:         []error{},
			wantErrsLen:  1,
			wantLast:     "only",
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.initialError.AppendErrors(test.errs...)

				// then
				assert.NotNil(t, got)
				assert.Len(t, got.Errors, test.wantErrsLen)

				if test.wantErrsLen > 0 {
					assert.Equal(t, test.wantLast, got.Errors[len(got.Errors)-1].Error())
				}

				assert.Same(t, test.initialError, got) // Should return same instance
			},
		)
	}
}

func TestStructuredErrorPrependErrors(t *testing.T) {
	t.Parallel()

	tests := []struct {
		initialError *StructuredError
		name         string
		wantFirst    string
		errs         []error
		wantErrsLen  int
	}{
		{
			name:         "given_error_when_prepend_empty_errors_then_no_change",
			initialError: New("test").WithErrors(stderrors.New("only")),
			errs:         []error{},
			wantErrsLen:  1,
			wantFirst:    "only",
		},
		{
			name:         "given_error_with_existing_errors_when_prepend_errors_then_appends_existing_to_new_slice",
			initialError: New("test").WithErrors(stderrors.New("existing")),
			errs:         []error{stderrors.New("prepended")},
			wantErrsLen:  1,
			wantFirst:    "existing",
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.initialError.PrependErrors(test.errs...)

				// then
				assert.NotNil(t, got)
				assert.Len(t, got.Errors, test.wantErrsLen)

				if test.wantErrsLen > 0 {
					assert.Equal(t, test.wantFirst, got.Errors[0].Error())
				}

				assert.Same(t, test.initialError, got) // Should return same instance
			},
		)
	}
}

func TestStructuredErrorUnwrap(t *testing.T) {
	t.Parallel()

	tests := []struct {
		err     *StructuredError
		name    string
		wantLen int
	}{
		{
			name:    "given_error_without_errors_when_unwrap_then_returns_empty_slice",
			err:     New("test"),
			wantLen: 0,
		},
		{
			name:    "given_error_with_single_error_when_unwrap_then_returns_single_error",
			err:     New("test").WithErrors(stderrors.New("child")),
			wantLen: 1,
		},
		{
			name:    "given_error_with_multiple_errors_when_unwrap_then_returns_all_errors",
			err:     New("test").WithErrors(stderrors.New("err1"), stderrors.New("err2"), stderrors.New("err3")),
			wantLen: 3,
		},
		{
			name:    "given_error_with_nil_error_when_unwrap_then_returns_slice_with_nil",
			err:     New("test").WithErrors(nil),
			wantLen: 1,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.err.Unwrap()

				// then
				assert.Len(t, got, test.wantLen)
			},
		)
	}
}

func TestStructuredErrorChaining(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		buildError func() *StructuredError
		// then
		wantMessage  string
		wantAttrs    int
		wantTags     int
		wantErrors   int
		wantHasStack bool
	}{
		{
			name: "given_chained_methods_when_building_error_then_all_fields_set",
			buildError: func() *StructuredError {
				return New("test error").
					WithAttrs(String("key", "value")).
					WithTags("tag1", "tag2").
					WithErrors(stderrors.New("child")).
					WithStack([]byte("stack trace"))
			},
			wantMessage:  "test error",
			wantAttrs:    1,
			wantTags:     2,
			wantErrors:   1,
			wantHasStack: true,
		},
		{
			name: "given_multiple_with_attrs_calls_when_building_error_then_just_last_attr_kept",
			buildError: func() *StructuredError {
				return New("test").
					WithAttrs(String("key1", "value1")).
					WithAttrs(String("key2", "value2")).
					WithAttrs(Int("key3", 42))
			},
			wantMessage:  "test",
			wantAttrs:    1,
			wantTags:     0,
			wantErrors:   0,
			wantHasStack: false,
		},
		{
			name: "given_multiple_with_errors_calls_when_building_error_then_just_last_error_kept",
			buildError: func() *StructuredError {
				return New("test").
					WithErrors(stderrors.New("err1")).
					WithErrors(stderrors.New("err2")).
					AppendErrors(stderrors.New("err3"))
			},
			wantMessage:  "test",
			wantAttrs:    0,
			wantTags:     0,
			wantErrors:   2,
			wantHasStack: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.buildError()

				// then
				assert.Equal(t, test.wantMessage, got.Message)
				assert.Len(t, got.Attrs, test.wantAttrs)
				assert.Len(t, got.Tags, test.wantTags)
				assert.Len(t, got.Errors, test.wantErrors)

				if test.wantHasStack {
					assert.NotEmpty(t, got.Stack)
				} else {
					assert.Empty(t, got.Stack)
				}
			},
		)
	}
}
