{{if .WithGenHeader -}}
// Code generated by errors_generator; DO NOT EDIT.
// Generated at {{.Date}}
// Version {{.Version}}

{{end -}}
package {{.PackageName}}

import (
	stderrors "errors"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestMaxDepthMarshal(t *testing.T) { //nolint:paralleltest // SetMaxDepthMarshal is not thread-safe
	tests := []struct {
		name string
		// given
		initialDepth int
		// then
		want int
	}{
		{
			name:         "given_default_depth_when_max_depth_marshal_then_returns_100",
			initialDepth: 100,
			want:         100,
		},
	}

	for _, tt := range tests { //nolint:paralleltest // SetMaxDepthMarshal is not thread-safe
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				// given
				SetMaxDepthMarshal(test.initialDepth)

				// when
				got := MaxDepthMarshal()

				// then
				assert.Equal(t, test.want, got)
			},
		)
	}
}

func TestSetMaxDepthMarshal(t *testing.T) { //nolint:paralleltest // SetMaxDepthMarshal is not thread-safe
	tests := []struct {
		name string
		// given
		depth int
		// then
		wantDepth int
	}{
		{
			name:      "given_positive_depth_when_set_max_depth_marshal_then_updates_max_depth",
			depth:     50,
			wantDepth: 50,
		},
		{
			name:      "given_zero_depth_when_set_max_depth_marshal_then_updates_max_depth",
			depth:     0,
			wantDepth: 0,
		},
		{
			name:      "given_negative_depth_when_set_max_depth_marshal_then_updates_max_depth",
			depth:     -1,
			wantDepth: -1,
		},
		{
			name:      "given_large_depth_when_set_max_depth_marshal_then_updates_max_depth",
			depth:     1000,
			wantDepth: 1000,
		},
	}

	for _, tt := range tests { //nolint:paralleltest // SetMaxDepthMarshal is not thread-safe
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				// when
				SetMaxDepthMarshal(test.depth)

				// then
				got := MaxDepthMarshal()
				assert.Equal(t, test.wantDepth, got)

				// verify ErrDepthExceeded is updated
				assert.NotNil(t, ErrDepthExceeded)
				assert.Equal(t, maxDepthExceeded, ErrDepthExceeded.Message)
			},
		)
	}
}

func TestNormalizerTargetAdd(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		initialErrs []error
		addErrs     []error
		// then
		wantLen int
	}{
		{
			name:        "given_empty_target_when_add_single_error_then_contains_one_error",
			initialErrs: []error{},
			addErrs:     []error{stderrors.New("test error")},
			wantLen:     1,
		},
		{
			name:        "given_empty_target_when_add_multiple_errors_then_contains_all_errors",
			initialErrs: []error{},
			addErrs:     []error{stderrors.New("error1"), stderrors.New("error2"), stderrors.New("error3")},
			wantLen:     3,
		},
		{
			name:        "given_existing_errors_when_add_more_errors_then_appends_to_existing",
			initialErrs: []error{stderrors.New("existing")},
			addErrs:     []error{stderrors.New("new1"), stderrors.New("new2")},
			wantLen:     3,
		},
		{
			name:        "given_empty_target_when_add_nil_error_then_contains_nil",
			initialErrs: []error{},
			addErrs:     []error{nil},
			wantLen:     1,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				target := &normalizerTarget{errs: test.initialErrs}

				// when
				target.add(test.addErrs...)

				// then
				assert.Len(t, target.errs, test.wantLen)
			},
		)
	}
}

func TestNormalizeErrors(t *testing.T) { //nolint:paralleltest,tparallel // SetMaxDepthMarshal is not thread-safe
	// Reset max depth for tests
	SetMaxDepthMarshal(100)

	tests := []struct {
		name    string
		errs    []error
		depth   int
		wantLen int
	}{
		{
			name:    "given_nil_error_when_normalize_errors_then_adds_nil_to_target",
			depth:   0,
			errs:    []error{nil},
			wantLen: 1,
		},
		{
			name:    "given_standard_error_when_normalize_errors_then_adds_error_to_target",
			depth:   0,
			errs:    []error{stderrors.New("standard error")},
			wantLen: 1,
		},
		{
			name:    "given_multiple_standard_errors_when_normalize_errors_then_adds_all_to_target",
			depth:   0,
			errs:    []error{stderrors.New("error1"), stderrors.New("error2")},
			wantLen: 2,
		},
		{
			name:    "given_structured_error_without_errors_when_normalize_errors_then_adds_error_to_target",
			depth:   0,
			errs:    []error{New("structured error")},
			wantLen: 1,
		},
		{
			name:  "given_structured_error_with_nested_errors_when_normalize_errors_then_normalizes_nested",
			depth: 0,
			errs: []error{
				New("parent").WithErrors(stderrors.New("child1"), stderrors.New("child2")),
			},
			wantLen: 1,
		},
		{
			name:    "given_nil_structured_error_when_normalize_errors_then_adds_nil_to_target",
			depth:   0,
			errs:    []error{(*StructuredError)(nil)},
			wantLen: 1,
		},
		{
			name:  "given_joined_structured_error_when_normalize_errors_then_flattens_errors",
			depth: 0,
			errs: []error{
				&StructuredError{
					Message: "joined",
					joined:  true,
					Errors:  []error{stderrors.New("err1"), stderrors.New("err2")},
				},
			},
			wantLen: 2,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				target := &normalizerTarget{errs: make([]error, 0)}

				// when
				normalizeErrors(test.depth, target, test.errs...)

				// then
				assert.Len(t, target.errs, test.wantLen)
			},
		)
	}
}

func TestNormalizeErrorsDepthExceeded(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name              string
		errs              []error
		maxDepth          int
		depth             int
		wantDepthExceeded bool
	}{
		{
			name:              "given_depth_exceeds_max_when_normalize_errors_then_adds_depth_exceeded_error",
			maxDepth:          5,
			depth:             6,
			errs:              []error{stderrors.New("test")},
			wantDepthExceeded: true,
		},
		{
			name:              "given_depth_equals_max_when_normalize_errors_then_processes_normally",
			maxDepth:          5,
			depth:             5,
			errs:              []error{stderrors.New("test")},
			wantDepthExceeded: false,
		},
		{
			name:              "given_depth_below_max_when_normalize_errors_then_processes_normally",
			maxDepth:          10,
			depth:             5,
			errs:              []error{stderrors.New("test")},
			wantDepthExceeded: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				SetMaxDepthMarshal(test.maxDepth)

				target := &normalizerTarget{errs: make([]error, 0)}

				// when
				normalizeErrors(test.depth, target, test.errs...)

				// then
				if test.wantDepthExceeded {
					assert.Len(t, target.errs, 1)
					assert.Equal(t, ErrDepthExceeded, target.errs[0])
				} else {
					assert.NotEmpty(t, target.errs)

					if len(target.errs) > 0 {
						assert.NotEqual(t, ErrDepthExceeded, target.errs[0])
					}
				}
			},
		)
	}
}

type singleUnwrapper struct {
	err error
}

func (s singleUnwrapper) Error() string {
	return "single unwrapper"
}

func (s singleUnwrapper) Unwrap() error {
	return s.err
}

type multiUnwrapper struct {
	errs []error
}

func (m multiUnwrapper) Error() string {
	return "multi unwrapper"
}

func (m multiUnwrapper) Unwrap() []error {
	return m.errs
}

func TestNormalizeErrorsWithUnwrapper(t *testing.T) {
	// Reset max depth for tests
	SetMaxDepthMarshal(100)

	t.Parallel()

	tests := []struct {
		name string
		// given
		errs []error
		// then
		wantLen int
	}{
		{
			name: "given_single_unwrapper_when_normalize_errors_then_unwraps_error",
			errs: []error{
				singleUnwrapper{err: stderrors.New("wrapped error")},
			},
			wantLen: 1,
		},
		{
			name: "given_multi_unwrapper_when_normalize_errors_then_unwraps_all_errors",
			errs: []error{
				multiUnwrapper{errs: []error{stderrors.New("err1"), stderrors.New("err2")}},
			},
			wantLen: 2,
		},
		{
			name: "given_single_unwrapper_with_nil_when_normalize_errors_then_adds_nil",
			errs: []error{
				singleUnwrapper{err: nil},
			},
			wantLen: 1,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				target := &normalizerTarget{errs: make([]error, 0)}

				// when
				normalizeErrors(0, target, test.errs...)

				// then
				assert.Len(t, target.errs, test.wantLen)
			},
		)
	}
}

func TestOr(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		vals []int
		// then
		want int
	}{
		{
			name: "given_first_non_zero_when_or_then_returns_first_non_zero",
			vals: []int{0, 0, 5, 10},
			want: 5,
		},
		{
			name: "given_all_zeros_when_or_then_returns_zero",
			vals: []int{0, 0, 0},
			want: 0,
		},
		{
			name: "given_first_value_non_zero_when_or_then_returns_first",
			vals: []int{3, 5, 7},
			want: 3,
		},
		{
			name: "given_empty_slice_when_or_then_returns_zero",
			vals: []int{},
			want: 0,
		},
		{
			name: "given_single_non_zero_when_or_then_returns_value",
			vals: []int{42},
			want: 42,
		},
		{
			name: "given_single_zero_when_or_then_returns_zero",
			vals: []int{0},
			want: 0,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := cmpOr(test.vals...)

				// then
				assert.Equal(t, test.want, got)
			},
		)
	}
}

func TestOrWithStrings(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		want string
		vals []string
	}{
		{
			name: "given_first_non_empty_when_or_then_returns_first_non_empty",
			vals: []string{"", "", "hello", "world"},
			want: "hello",
		},
		{
			name: "given_all_empty_when_or_then_returns_empty",
			vals: []string{"", "", ""},
			want: "",
		},
		{
			name: "given_first_value_non_empty_when_or_then_returns_first",
			vals: []string{"first", "second", "third"},
			want: "first",
		},
		{
			name: "given_empty_slice_when_or_then_returns_empty_string",
			vals: []string{},
			want: "",
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := cmpOr(test.vals...)

				// then
				assert.Equal(t, test.want, got)
			},
		)
	}
}

func TestOrWithBool(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		vals []bool
		// then
		want bool
	}{
		{
			name: "given_first_true_when_or_then_returns_true",
			vals: []bool{false, false, true, false},
			want: true,
		},
		{
			name: "given_all_false_when_or_then_returns_false",
			vals: []bool{false, false, false},
			want: false,
		},
		{
			name: "given_first_value_true_when_or_then_returns_true",
			vals: []bool{true, true, false},
			want: true,
		},
		{
			name: "given_empty_slice_when_or_then_returns_false",
			vals: []bool{},
			want: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := cmpOr(test.vals...)

				// then
				assert.Equal(t, test.want, got)
			},
		)
	}
}
