{{if .WithGenHeader -}}
// Code generated by errors_generator; DO NOT EDIT.
// Generated at {{.Date}}
// Version {{.Version}}

{{end -}}
package {{.PackageName}}

import (
	stderrors "errors"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/zap/zapcore"
)

func TestStructuredErrorMarshalLogObject(t *testing.T) {
	t.Parallel()

	tests := []struct {
		err     *StructuredError
		name    string
		wantErr bool
	}{
		{
			name:    "given_nil_error_when_marshal_log_object_then_no_error",
			err:     nil,
			wantErr: false,
		},
		{
			name:    "given_error_with_message_when_marshal_log_object_then_no_error",
			err:     New("test error"),
			wantErr: false,
		},
		{
			name:    "given_error_with_tags_when_marshal_log_object_then_no_error",
			err:     New("test").WithTags("tag1", "tag2"),
			wantErr: false,
		},
		{
			name:    "given_error_with_attrs_when_marshal_log_object_then_no_error",
			err:     New("test").WithAttrs(String("key", "value")),
			wantErr: false,
		},
		{
			name:    "given_error_with_errors_when_marshal_log_object_then_no_error",
			err:     New("parent").WithErrors(stderrors.New("child")),
			wantErr: false,
		},
		{
			name:    "given_error_with_stack_when_marshal_log_object_then_no_error",
			err:     New("test").WithStack([]byte("stack trace")),
			wantErr: false,
		},
		{
			name: "given_error_with_all_fields_when_marshal_log_object_then_no_error",
			err: New("test").
				WithTags("tag").
				WithAttrs(String("key", "value")).
				WithErrors(stderrors.New("child")).
				WithStack([]byte("stack")),
			wantErr: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				encoder := zapcore.NewMapObjectEncoder()

				// when
				err := test.err.MarshalLogObject(encoder)

				// then
				if test.wantErr {
					require.Error(t, err)
				} else {
					require.NoError(t, err)
				}
			},
		)
	}
}

func TestStructuredErrorMarshalLogObjectFields(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		err *StructuredError
		// then
		wantKeys []string
	}{
		{
			name:     "given_nil_error_when_marshal_log_object_then_has_message_field",
			err:      nil,
			wantKeys: []string{"message"},
		},
		{
			name:     "given_error_with_message_when_marshal_log_object_then_has_message_field",
			err:      New("test"),
			wantKeys: []string{"message"},
		},
		{
			name:     "given_error_with_tags_when_marshal_log_object_then_has_message_and_tags",
			err:      New("test").WithTags("tag1"),
			wantKeys: []string{"message", "tags"},
		},
		{
			name:     "given_error_with_attrs_when_marshal_log_object_then_has_message_and_attrs",
			err:      New("test").WithAttrs(String("key", "value")),
			wantKeys: []string{"message", "attrs"},
		},
		{
			name:     "given_error_with_errors_when_marshal_log_object_then_has_message_and_errors",
			err:      New("parent").WithErrors(stderrors.New("child")),
			wantKeys: []string{"message", "errors"},
		},
		{
			name:     "given_error_with_stack_when_marshal_log_object_then_has_message_and_stack",
			err:      New("test").WithStack([]byte("stack")),
			wantKeys: []string{"message", "stack"},
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				encoder := zapcore.NewMapObjectEncoder()

				// when
				err := test.err.MarshalLogObject(encoder)

				// then
				require.NoError(t, err)

				fields := encoder.Fields
				for _, key := range test.wantKeys {
					assert.Contains(t, fields, key)
				}
			},
		)
	}
}

func TestAttrMarshalLogObject(t *testing.T) {
	t.Parallel()

	tests := []struct {
		attr    *Attr
		name    string
		wantErr bool
	}{
		{
			name:    "given_nil_attr_when_marshal_log_object_then_no_error",
			attr:    nil,
			wantErr: false,
		},
		{
			name:    "given_string_attr_when_marshal_log_object_then_no_error",
			attr:    &Attr{Type: StringType, Key: "name", Value: "test"},
			wantErr: false,
		},
		{
			name:    "given_int_attr_when_marshal_log_object_then_no_error",
			attr:    &Attr{Type: IntType, Key: "count", Value: 42},
			wantErr: false,
		},
		{
			name:    "given_bool_attr_when_marshal_log_object_then_no_error",
			attr:    &Attr{Type: BoolType, Key: "active", Value: true},
			wantErr: false,
		},
		{
			name:    "given_float64_attr_when_marshal_log_object_then_no_error",
			attr:    &Attr{Type: Float64Type, Key: "price", Value: 99.99},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				encoder := zapcore.NewMapObjectEncoder()

				// when
				err := test.attr.MarshalLogObject(encoder)

				// then
				if test.wantErr {
					require.Error(t, err)
				} else {
					require.NoError(t, err)
				}
			},
		)
	}
}

func TestAttrMarshalLogObjectWithTypes(t *testing.T) {
	fixedTime := time.Date(2023, 10, 15, 12, 30, 0, 0, time.UTC)
	fixedDuration := 5 * time.Second

	t.Parallel()

	tests := []struct {
		name string
		// given
		attr *Attr
		// then
		wantKey string
	}{
		{
			name:    "given_string_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: StringType, Key: "name", Value: "test"},
			wantKey: "name",
		},
		{
			name:    "given_int_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: IntType, Key: "count", Value: 42},
			wantKey: "count",
		},
		{
			name:    "given_int64_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: Int64Type, Key: "id", Value: int64(123)},
			wantKey: "id",
		},
		{
			name:    "given_uint64_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: Uint64Type, Key: "uid", Value: uint64(456)},
			wantKey: "uid",
		},
		{
			name:    "given_float64_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: Float64Type, Key: "price", Value: 99.99},
			wantKey: "price",
		},
		{
			name:    "given_bool_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: BoolType, Key: "active", Value: true},
			wantKey: "active",
		},
		{
			name:    "given_time_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: TimeType, Key: "created", Value: fixedTime},
			wantKey: "created",
		},
		{
			name:    "given_duration_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: DurationType, Key: "timeout", Value: fixedDuration},
			wantKey: "timeout",
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				encoder := zapcore.NewMapObjectEncoder()

				// when
				err := test.attr.MarshalLogObject(encoder)

				// then
				require.NoError(t, err)
				assert.Contains(t, encoder.Fields, test.wantKey)
			},
		)
	}
}

func TestAttrMarshalLogObjectWithSlices(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		attr *Attr
		// then
		wantKey string
		wantErr bool
	}{
		{
			name:    "given_bools_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: BoolsType, Key: "flags", Value: []bool{true, false}},
			wantKey: "flags",
			wantErr: false,
		},
		{
			name:    "given_ints_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: IntsType, Key: "numbers", Value: []int{1, 2, 3}},
			wantKey: "numbers",
			wantErr: false,
		},
		{
			name:    "given_int64s_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: Int64sType, Key: "ids", Value: []int64{1, 2, 3}},
			wantKey: "ids",
			wantErr: false,
		},
		{
			name:    "given_uint64s_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: Uint64sType, Key: "uids", Value: []uint64{1, 2, 3}},
			wantKey: "uids",
			wantErr: false,
		},
		{
			name:    "given_float64s_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: Float64sType, Key: "prices", Value: []float64{1.1, 2.2}},
			wantKey: "prices",
			wantErr: false,
		},
		{
			name:    "given_strings_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: StringsType, Key: "tags", Value: []string{"tag1", "tag2"}},
			wantKey: "tags",
			wantErr: false,
		},
		{
			name:    "given_times_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: TimesType, Key: "timestamps", Value: []time.Time{time.Now()}},
			wantKey: "timestamps",
			wantErr: false,
		},
		{
			name:    "given_durations_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: DurationsType, Key: "timeouts", Value: []time.Duration{5 * time.Second}},
			wantKey: "timeouts",
			wantErr: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				encoder := zapcore.NewMapObjectEncoder()

				// when
				err := test.attr.MarshalLogObject(encoder)

				// then
				if test.wantErr {
					require.Error(t, err)
				} else {
					require.NoError(t, err)
					assert.Contains(t, encoder.Fields, test.wantKey)
				}
			},
		)
	}
}

func TestAttrMarshalLogObjectWithObjectType(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		attr *Attr
		// then
		wantKey string
		wantErr bool
	}{
		{
			name:    "given_object_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: ObjectType, Key: "obj", Value: []Attr{String("key", "value")}},
			wantKey: "obj",
			wantErr: false,
		},
		{
			name:    "given_empty_object_attr_when_marshal_log_object_then_has_key",
			attr:    &Attr{Type: ObjectType, Key: "empty", Value: []Attr{}},
			wantKey: "empty",
			wantErr: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				encoder := zapcore.NewMapObjectEncoder()

				// when
				err := test.attr.MarshalLogObject(encoder)

				// then
				if test.wantErr {
					require.Error(t, err)
				} else {
					require.NoError(t, err)
					assert.Contains(t, encoder.Fields, test.wantKey)
				}
			},
		)
	}
}

func TestErrorToZap(t *testing.T) {
	t.Parallel()

	tests := []struct {
		err     error
		name    string
		wantErr bool
	}{
		{
			name:    "given_nil_error_when_error_to_zap_then_no_error",
			err:     nil,
			wantErr: false,
		},
		{
			name:    "given_standard_error_when_error_to_zap_then_no_error",
			err:     stderrors.New("standard error"),
			wantErr: false,
		},
		{
			name:    "given_structured_error_when_error_to_zap_then_no_error",
			err:     New("structured"),
			wantErr: false,
		},
		{
			name:    "given_error_with_whitespace_when_error_to_zap_then_no_error",
			err:     stderrors.New("  error  "),
			wantErr: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				encoder := zapcore.NewMapObjectEncoder()

				// when
				err := errorToZap(encoder, test.err)

				// then
				if test.wantErr {
					require.Error(t, err)
				} else {
					require.NoError(t, err)
					assert.Contains(t, encoder.Fields, "message")
				}
			},
		)
	}
}

func TestSliceToZapWithStrings(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		key   string
		slice []string
		// then
		wantErr bool
	}{
		{
			name:    "given_empty_slice_when_slice_to_zap_then_no_error",
			key:     "tags",
			slice:   []string{},
			wantErr: false,
		},
		{
			name:    "given_single_item_slice_when_slice_to_zap_then_no_error",
			key:     "tags",
			slice:   []string{"tag1"},
			wantErr: false,
		},
		{
			name:    "given_multiple_items_slice_when_slice_to_zap_then_no_error",
			key:     "tags",
			slice:   []string{"tag1", "tag2", "tag3"},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				encoder := zapcore.NewMapObjectEncoder()

				// when
				err := sliceToZap(encoder, test.key, test.slice)

				// then
				if test.wantErr {
					require.Error(t, err)
				} else {
					require.NoError(t, err)
					assert.Contains(t, encoder.Fields, test.key)
				}
			},
		)
	}
}

func TestSliceToZapWithErrors(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		key  string
		errs []error
		// then
		wantErr bool
	}{
		{
			name:    "given_empty_errors_slice_when_slice_to_zap_then_no_error",
			key:     "errors",
			errs:    []error{},
			wantErr: false,
		},
		{
			name:    "given_single_error_when_slice_to_zap_then_no_error",
			key:     "errors",
			errs:    []error{stderrors.New("error1")},
			wantErr: false,
		},
		{
			name:    "given_multiple_errors_when_slice_to_zap_then_no_error",
			key:     "errors",
			errs:    []error{stderrors.New("error1"), stderrors.New("error2")},
			wantErr: false,
		},
		{
			name:    "given_nil_error_when_slice_to_zap_then_no_error",
			key:     "errors",
			errs:    []error{nil},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				encoder := zapcore.NewMapObjectEncoder()

				// when
				err := sliceToZap(encoder, test.key, test.errs)

				// then
				if test.wantErr {
					require.Error(t, err)
				} else {
					require.NoError(t, err)
					assert.Contains(t, encoder.Fields, test.key)
				}
			},
		)
	}
}

func TestSliceToZapWithAttrs(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		key   string
		attrs []Attr
		// then
		wantErr bool
	}{
		{
			name:    "given_empty_attrs_slice_when_slice_to_zap_then_no_error",
			key:     "attrs",
			attrs:   []Attr{},
			wantErr: false,
		},
		{
			name:    "given_single_attr_when_slice_to_zap_then_no_error",
			key:     "attrs",
			attrs:   []Attr{String("key", "value")},
			wantErr: false,
		},
		{
			name:    "given_multiple_attrs_when_slice_to_zap_then_no_error",
			key:     "attrs",
			attrs:   []Attr{String("key1", "value1"), Int("key2", 42)},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				encoder := zapcore.NewMapObjectEncoder()

				// when
				err := sliceToZap(encoder, test.key, test.attrs)

				// then
				if test.wantErr {
					require.Error(t, err)
				} else {
					require.NoError(t, err)
					assert.Contains(t, encoder.Fields, test.key)
				}
			},
		)
	}
}

func TestSliceToZapWithTypedSlices(t *testing.T) {
	t.Parallel()

	tests := []struct {
		slice   any
		name    string
		key     string
		wantErr bool
	}{
		{
			name:    "given_bool_slice_when_slice_to_zap_then_no_error",
			key:     "flags",
			slice:   []bool{true, false},
			wantErr: false,
		},
		{
			name:    "given_int_slice_when_slice_to_zap_then_no_error",
			key:     "numbers",
			slice:   []int{1, 2, 3},
			wantErr: false,
		},
		{
			name:    "given_int64_slice_when_slice_to_zap_then_no_error",
			key:     "ids",
			slice:   []int64{1, 2, 3},
			wantErr: false,
		},
		{
			name:    "given_uint64_slice_when_slice_to_zap_then_no_error",
			key:     "uids",
			slice:   []uint64{1, 2, 3},
			wantErr: false,
		},
		{
			name:    "given_float64_slice_when_slice_to_zap_then_no_error",
			key:     "prices",
			slice:   []float64{1.1, 2.2},
			wantErr: false,
		},
		{
			name:    "given_time_slice_when_slice_to_zap_then_no_error",
			key:     "times",
			slice:   []time.Time{time.Now()},
			wantErr: false,
		},
		{
			name:    "given_duration_slice_when_slice_to_zap_then_no_error",
			key:     "durations",
			slice:   []time.Duration{5 * time.Second},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				encoder := zapcore.NewMapObjectEncoder()

				// when
				var err error

				switch v := test.slice.(type) {
				case []bool:
					err = sliceToZap(encoder, test.key, v)
				case []int:
					err = sliceToZap(encoder, test.key, v)
				case []int64:
					err = sliceToZap(encoder, test.key, v)
				case []uint64:
					err = sliceToZap(encoder, test.key, v)
				case []float64:
					err = sliceToZap(encoder, test.key, v)
				case []time.Time:
					err = sliceToZap(encoder, test.key, v)
				case []time.Duration:
					err = sliceToZap(encoder, test.key, v)
				}

				// then
				if test.wantErr {
					require.Error(t, err)
				} else {
					require.NoError(t, err)
					assert.Contains(t, encoder.Fields, test.key)
				}
			},
		)
	}
}

func TestStructuredErrorMarshalLogObjectIntegration(t *testing.T) {
	t.Parallel()

	tests := []struct {
		err            *StructuredError
		name           string
		wantFieldCount int
	}{
		{
			name:           "given_simple_error_when_marshal_log_object_then_has_one_field",
			err:            New("test"),
			wantFieldCount: 1,
		},
		{
			name:           "given_error_with_tags_when_marshal_log_object_then_has_two_fields",
			err:            New("test").WithTags("tag1"),
			wantFieldCount: 2,
		},
		{
			name: "given_complex_error_when_marshal_log_object_then_has_all_fields",
			err: New("parent").
				WithTags("api").
				WithAttrs(String("request_id", "123")).
				WithErrors(stderrors.New("child")).
				WithStack([]byte("stack")),
			wantFieldCount: 5,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// given
				encoder := zapcore.NewMapObjectEncoder()

				// when
				err := test.err.MarshalLogObject(encoder)

				// then
				require.NoError(t, err)
				assert.Len(t, encoder.Fields, test.wantFieldCount)
			},
		)
	}
}
