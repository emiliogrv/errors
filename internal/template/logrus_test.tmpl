{{if .WithGenHeader -}}
// Code generated by errors_generator; DO NOT EDIT.
// Generated at {{.Date}}
// Version {{.Version}}

{{end -}}
package {{.PackageName}}

import (
	"testing"

	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
)

func TestStructuredErrorMarshalLogrusFields(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		err *StructuredError
		// then
		wantKeys []string
	}{
		{
			name:     "given_nil_error_when_marshal_logrus_fields_then_returns_fields_with_nil_message",
			err:      nil,
			wantKeys: []string{"message"},
		},
		{
			name:     "given_error_with_message_when_marshal_logrus_fields_then_returns_fields_with_message",
			err:      New("test error"),
			wantKeys: []string{"message"},
		},
		{
			name:     "given_error_with_empty_message_when_marshal_logrus_fields_then_returns_fields_with_nil_value",
			err:      New(""),
			wantKeys: []string{"message"},
		},
		{
			name:     "given_error_with_tags_when_marshal_logrus_fields_then_returns_fields_with_tags",
			err:      New("test").WithTags("tag1", "tag2"),
			wantKeys: []string{"message", "tags"},
		},
		{
			name:     "given_error_with_attrs_when_marshal_logrus_fields_then_returns_fields_with_attrs",
			err:      New("test").WithAttrs(String("key", "value")),
			wantKeys: []string{"message", "attrs"},
		},
		{
			name:     "given_error_with_errors_when_marshal_logrus_fields_then_returns_fields_with_errors",
			err:      New("parent").WithErrors(New("child")),
			wantKeys: []string{"message", "errors"},
		},
		{
			name:     "given_error_with_stack_when_marshal_logrus_fields_then_returns_fields_with_stack",
			err:      New("test").WithStack([]byte("stack trace")),
			wantKeys: []string{"message", "stack"},
		},
		{
			name: "given_error_with_all_fields_when_marshal_logrus_fields_then_returns_all_fields",
			err: New("test").
				WithTags("tag").
				WithAttrs(String("key", "value")).
				WithErrors(New("child")).
				WithStack([]byte("stack")),
			wantKeys: []string{"message", "tags", "attrs", "errors", "stack"},
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.err.MarshalLogrusFields()

				// then
				assert.NotNil(t, got)
				assert.Len(t, got, len(test.wantKeys))

				for _, key := range test.wantKeys {
					assert.Contains(t, got, key)
				}
			},
		)
	}
}

func TestStructuredErrorMarshalLogrusFieldsValues(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		err *StructuredError
		// then
		wantMessageValue string
	}{
		{
			name:             "given_nil_error_when_marshal_logrus_fields_then_message_is_nil_value",
			err:              nil,
			wantMessageValue: nilValue,
		},
		{
			name:             "given_error_with_message_when_marshal_logrus_fields_then_message_is_correct",
			err:              New("test message"),
			wantMessageValue: "test message",
		},
		{
			name:             "given_error_with_empty_message_when_marshal_logrus_fields_then_message_is_nil_value",
			err:              New(""),
			wantMessageValue: nilValue,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.err.MarshalLogrusFields()

				// then
				assert.Equal(t, test.wantMessageValue, got["message"])
			},
		)
	}
}

func TestAttrMarshalLogrusFields(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		// given
		attr *Attr
		// then
		wantKeys []string
	}{
		{
			name:     "given_nil_attr_when_marshal_logrus_fields_then_returns_fields_with_nil_key",
			attr:     nil,
			wantKeys: []string{nilValue},
		},
		{
			name:     "given_string_attr_when_marshal_logrus_fields_then_returns_fields_with_key",
			attr:     &Attr{Type: StringType, Key: "test", Value: "value"},
			wantKeys: []string{"test"},
		},
		{
			name:     "given_int_attr_when_marshal_logrus_fields_then_returns_fields_with_key",
			attr:     &Attr{Type: IntType, Key: "count", Value: 42},
			wantKeys: []string{"count"},
		},
		{
			name:     "given_bool_attr_when_marshal_logrus_fields_then_returns_fields_with_key",
			attr:     &Attr{Type: BoolType, Key: "flag", Value: true},
			wantKeys: []string{"flag"},
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.attr.MarshalLogrusFields()

				// then
				assert.NotNil(t, got)
				assert.Len(t, got, len(test.wantKeys))

				for _, key := range test.wantKeys {
					assert.Contains(t, got, key)
				}
			},
		)
	}
}

func TestAttrMarshalLogrusFieldsValues(t *testing.T) {
	t.Parallel()

	tests := []struct {
		wantValue any
		attr      *Attr
		name      string
		wantKey   string
	}{
		{
			name:      "given_string_attr_when_marshal_logrus_fields_then_value_is_string",
			attr:      &Attr{Type: StringType, Key: "name", Value: "test"},
			wantKey:   "name",
			wantValue: "test",
		},
		{
			name:      "given_int_attr_when_marshal_logrus_fields_then_value_is_int",
			attr:      &Attr{Type: IntType, Key: "count", Value: 42},
			wantKey:   "count",
			wantValue: 42,
		},
		{
			name:      "given_bool_attr_when_marshal_logrus_fields_then_value_is_bool",
			attr:      &Attr{Type: BoolType, Key: "active", Value: true},
			wantKey:   "active",
			wantValue: true,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.attr.MarshalLogrusFields()

				// then
				assert.Equal(t, test.wantValue, got[test.wantKey])
			},
		)
	}
}

func TestLogrusFieldsMarshalerInterface(t *testing.T) {
	t.Parallel()

	tests := []struct {
		marshaler      LogrusFieldsMarshaler
		name           string
		wantImplements bool
	}{
		{
			name:           "given_structured_error_when_check_interface_then_implements_logrus_fields_marshaler",
			marshaler:      New("test"),
			wantImplements: true,
		},
		{
			name:           "given_attr_when_check_interface_then_implements_logrus_fields_marshaler",
			marshaler:      &Attr{Type: StringType, Key: "key", Value: "value"},
			wantImplements: true,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				fields := test.marshaler.MarshalLogrusFields()

				// then
				assert.NotNil(t, fields)
				assert.IsType(t, logrus.Fields{}, fields)
			},
		)
	}
}

func TestStructuredErrorMarshalLogrusFieldsWithComplexData(t *testing.T) {
	t.Parallel()

	tests := []struct {
		err          *StructuredError
		name         string
		wantTagsLen  int
		wantAttrsLen int
		wantErrsLen  int
	}{
		{
			name:         "given_error_with_multiple_tags_when_marshal_logrus_fields_then_includes_all_tags",
			err:          New("test").WithTags("tag1", "tag2", "tag3"),
			wantTagsLen:  3,
			wantAttrsLen: 0,
			wantErrsLen:  0,
		},
		{
			name:         "given_error_with_multiple_attrs_when_marshal_logrus_fields_then_includes_all_attrs",
			err:          New("test").WithAttrs(String("key1", "val1"), String("key2", "val2")),
			wantTagsLen:  0,
			wantAttrsLen: 2,
			wantErrsLen:  0,
		},
		{
			name:         "given_error_with_multiple_errors_when_marshal_logrus_fields_then_includes_all_errors",
			err:          New("parent").WithErrors(New("child1"), New("child2")),
			wantTagsLen:  0,
			wantAttrsLen: 0,
			wantErrsLen:  2,
		},
	}

	for _, tt := range tests {
		test := tt
		t.Run(
			test.name, func(t *testing.T) {
				t.Parallel()

				// when
				got := test.err.MarshalLogrusFields()

				// then
				if test.wantTagsLen > 0 {
					tags, ok := got["tags"].([]string)
					assert.True(t, ok)
					assert.Len(t, tags, test.wantTagsLen)
				}

				if test.wantAttrsLen > 0 {
					attrs, ok := got["attrs"].(map[string]any)
					assert.True(t, ok)
					assert.Len(t, attrs, test.wantAttrsLen)
				}

				if test.wantErrsLen > 0 {
					errs, ok := got["errors"].([]map[string]any)
					assert.True(t, ok)
					assert.Len(t, errs, test.wantErrsLen)
				}
			},
		)
	}
}
