{{if .WithGenHeader -}}
// Code generated by errors_generator; DO NOT EDIT.
// Generated at {{.Date}}
// Version {{.Version}}

{{end -}}
package {{.PackageName}}

import (
	stderrors "errors"
	"strings"
	"time"

	"go.uber.org/zap/zapcore"
)

var (
	// ErrUnmarshalZap is returned when unmarshaling fails.
	ErrUnmarshalZap = New("failed to unmarshal zap")
)

// MarshalLogObject is the implementation for zapcore.ObjectMarshaler.
//
// It marshals the StructuredError into the given zapcore.ObjectEncoder.
// If the receiver is nil, it adds a single field to the encoder with the key "message"
// and the value nilValue.
//
// Otherwise, it will have the following attributes:
//   - Message
//   - Tags
//   - Attrs
//   - Errors
//   - Stack.
//
// Usage must be with zap.Any or zap.Object.
func (receiver *StructuredError) MarshalLogObject(encoder zapcore.ObjectEncoder) error {
	if receiver == nil {
		encoder.AddString(messageKey, nilValue)

		return nil
	}

	encoder.AddString(messageKey, cmpOr(receiver.Message, nilValue))

	if len(receiver.Tags) > zero {
		err := sliceToZap(encoder, tagsKey, receiver.Tags)
		if err != nil {
			return err
		}
	}

	if len(receiver.Attrs) > zero {
		err := sliceToZap(encoder, attrsKey, receiver.Attrs)
		if err != nil {
			return err
		}
	}

	if len(receiver.Errors) > zero {
		target := normalizerTarget{
			errs: make([]error, zero, len(receiver.Errors)),
		}
		normalizeErrors(zero, &target, receiver.Errors...)

		err := sliceToZap(encoder, errorsKey, target.errs)
		if err != nil {
			return err
		}
	}

	if len(receiver.Stack) > zero {
		err := sliceToZap(encoder, stackKey, strings.Split(string(receiver.Stack), newLine))
		if err != nil {
			return err
		}
	}

	return nil
}

// MarshalLogObject is the implementation for zapcore.ObjectMarshaler.
//
// It marshals the Attr into the given zapcore.ObjectEncoder.
// If the receiver is nil, it adds a single field to the encoder with the key "message"
// and the value nilValue.
//
// Otherwise, it will have the following attributes:
//   - message: the receiver's key, or nilValue if the receiver is nil.
//   - value: the receiver's value, or ignored if the receiver is nil.
//
// Usage must be with zap.Any or zap.Object.
//
//nolint:forcetypeassert,errcheck // XXXType helpers avoid using reflection
func (receiver *Attr) MarshalLogObject(encoder zapcore.ObjectEncoder) error {
	if receiver == nil {
		encoder.AddString(nilValue, nilValue)

		return nil
	}

	switch receiver.Type {
	case AnyType:
		return JoinIf(encoder.AddReflected(receiver.Key, receiver.Value), ErrUnmarshalZap)
	case ObjectType:
		return sliceToZap(encoder, receiver.Key, receiver.Value.([]Attr))
	case BoolType:
		encoder.AddBool(receiver.Key, receiver.Value.(bool))
	case BoolsType:
		return sliceToZap(encoder, receiver.Key, receiver.Value.([]bool))
	case TimeType:
		encoder.AddTime(receiver.Key, receiver.Value.(time.Time))
	case TimesType:
		return sliceToZap(encoder, receiver.Key, receiver.Value.([]time.Time))
	case DurationType:
		encoder.AddDuration(receiver.Key, receiver.Value.(time.Duration))
	case DurationsType:
		return sliceToZap(encoder, receiver.Key, receiver.Value.([]time.Duration))
	case IntType:
		encoder.AddInt(receiver.Key, receiver.Value.(int))
	case IntsType:
		return sliceToZap(encoder, receiver.Key, receiver.Value.([]int))
	case Int64Type:
		encoder.AddInt64(receiver.Key, receiver.Value.(int64))
	case Int64sType:
		return sliceToZap(encoder, receiver.Key, receiver.Value.([]int64))
	case Uint64Type:
		encoder.AddUint64(receiver.Key, receiver.Value.(uint64))
	case Uint64sType:
		return sliceToZap(encoder, receiver.Key, receiver.Value.([]uint64))
	case Float64Type:
		encoder.AddFloat64(receiver.Key, receiver.Value.(float64))
	case Float64sType:
		return sliceToZap(encoder, receiver.Key, receiver.Value.([]float64))
	case StringType:
		encoder.AddString(receiver.Key, receiver.Value.(string))
	case StringsType:
		return sliceToZap(encoder, receiver.Key, receiver.Value.([]string))
	default:
		return JoinIf(encoder.AddReflected(receiver.Key, receiver.Value), ErrUnmarshalZap)
	}

	return nil
}

// errorToZap marshals the error into the given zapcore.ObjectEncoder.
// If the receiver is nil, it adds a single field to the encoder with the key "message"
// and the value nilValue.
//
// Otherwise, it will have the following attributes:
//   - message: the receiver's message, or nilValue if the receiver is nil.
func errorToZap(encoder zapcore.ObjectEncoder, err error) error {
	var value *StructuredError
	switch {
	case err == nil:
		encoder.AddString(messageKey, nilValue)
	case stderrors.As(err, &value):
		return value.MarshalLogObject(encoder)
	default:
		errStr := strings.TrimSpace(err.Error())
		encoder.AddString(messageKey, cmpOr(errStr, nilValue))
	}

	return nil
}

// sliceToZap marshals the given slice into the given zapcore.ObjectEncoder.
//
// If the receiver is nil, it adds a single field to the encoder with the key "message"
// and the value nilValue.
//
// Otherwise, it will have the following attributes:
//   - message: the receiver's key, or nilValue if the receiver is nil.
//   - value: the receiver's value, or ignored if the receiver is nil.
func sliceToZap[T any](encoder zapcore.ObjectEncoder, key string, slice []T) error {
	if len(slice) == zero {
		return JoinIf(
			encoder.AddArray(
				key,
				zapcore.ArrayMarshalerFunc(func(zapcore.ArrayEncoder) error { return nil }),
			),
			ErrUnmarshalZap,
		)
	}

	switch values := any(slice).(type) {
	case []Attr:
		return JoinIf(
			encoder.AddObject(
				key,
				zapcore.ObjectMarshalerFunc(
					func(encoderObj zapcore.ObjectEncoder) error {
						for _, value := range values {
							err := value.MarshalLogObject(encoderObj)
							if err != nil {
								return err
							}
						}

						return nil
					},
				),
			),
			ErrUnmarshalZap,
		)
	case []error:
		return JoinIf(
			encoder.AddArray(
				key,
				zapcore.ArrayMarshalerFunc(
					func(encoderArr zapcore.ArrayEncoder) error {
						for _, value := range values {
							err := encoderArr.AppendObject(
								zapcore.ObjectMarshalerFunc(
									func(encoderObj zapcore.ObjectEncoder) error {
										return errorToZap(encoderObj, value)
									},
								),
							)
							if err != nil {
								return JoinIf(err, ErrUnmarshalZap)
							}
						}

						return nil
					},
				),
			),
			ErrUnmarshalZap,
		)
	case []bool:
		return JoinIf(
			encoder.AddArray(
				key,
				zapcore.ArrayMarshalerFunc(
					func(encoderArr zapcore.ArrayEncoder) error {
						for _, value := range values {
							encoderArr.AppendBool(value)
						}

						return nil
					},
				),
			),
			ErrUnmarshalZap,
		)
	case []time.Time:
		return JoinIf(
			encoder.AddArray(
				key,
				zapcore.ArrayMarshalerFunc(
					func(encoderArr zapcore.ArrayEncoder) error {
						for _, value := range values {
							encoderArr.AppendTime(value)
						}

						return nil
					},
				),
			),
			ErrUnmarshalZap,
		)
	case []time.Duration:
		return JoinIf(
			encoder.AddArray(
				key,
				zapcore.ArrayMarshalerFunc(
					func(encoderArr zapcore.ArrayEncoder) error {
						for _, value := range values {
							encoderArr.AppendDuration(value)
						}

						return nil
					},
				),
			),
			ErrUnmarshalZap,
		)
	case []int:
		return JoinIf(
			encoder.AddArray(
				key,
				zapcore.ArrayMarshalerFunc(
					func(encoderArr zapcore.ArrayEncoder) error {
						for _, value := range values {
							encoderArr.AppendInt(value)
						}

						return nil
					},
				),
			),
			ErrUnmarshalZap,
		)
	case []int64:
		return JoinIf(
			encoder.AddArray(
				key,
				zapcore.ArrayMarshalerFunc(
					func(encoderArr zapcore.ArrayEncoder) error {
						for _, value := range values {
							encoderArr.AppendInt64(value)
						}

						return nil
					},
				),
			),
			ErrUnmarshalZap,
		)
	case []uint64:
		return JoinIf(
			encoder.AddArray(
				key,
				zapcore.ArrayMarshalerFunc(
					func(encoderArr zapcore.ArrayEncoder) error {
						for _, value := range values {
							encoderArr.AppendUint64(value)
						}

						return nil
					},
				),
			),
			ErrUnmarshalZap,
		)
	case []float64:
		return JoinIf(
			encoder.AddArray(
				key,
				zapcore.ArrayMarshalerFunc(
					func(encoderArr zapcore.ArrayEncoder) error {
						for _, value := range values {
							encoderArr.AppendFloat64(value)
						}

						return nil
					},
				),
			),
			ErrUnmarshalZap,
		)
	case []string:
		return JoinIf(
			encoder.AddArray(
				key,
				zapcore.ArrayMarshalerFunc(
					func(encoderArr zapcore.ArrayEncoder) error {
						for _, value := range values {
							encoderArr.AppendString(strings.TrimSpace(value))
						}

						return nil
					},
				),
			),
			ErrUnmarshalZap,
		)
	default:
		return JoinIf(
			encoder.AddArray(
				key,
				zapcore.ArrayMarshalerFunc(
					func(encoderArr zapcore.ArrayEncoder) error {
						for _, value := range slice {
							err := encoderArr.AppendReflected(value)
							if err != nil {
								return JoinIf(err, ErrUnmarshalZap)
							}
						}

						return nil
					},
				),
			),
			ErrUnmarshalZap,
		)
	}
}
