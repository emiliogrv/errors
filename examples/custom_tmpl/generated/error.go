// Code generated by errors_generator; DO NOT EDIT.
// Generated at 2025-10-19T16:34:35-03:00
// Version 0.0.1

package errors

import (
	"fmt"
)

type (
	// MultiUnwrapper represents errors that unwrap to multiple underlying errors.
	MultiUnwrapper interface {
		Unwrap() []error
	}

	// SingleUnwrapper represents errors that unwrap to a single underlying error.
	SingleUnwrapper interface {
		Unwrap() error
	}

	// StructuredError represents an error with structured metadata including attributes,
	// nested errors, tags, and optional stack traces.
	StructuredError struct {
		// Message is the primary error message.
		// It is the only required field.
		// If empty, the error is considered nil with and labeled with "!NILVALUE"
		Message string `json:"message,omitempty"`

		// Attrs contains key-value pairs providing additional context.
		// It is optional.
		// If empty, or nil, it will be marshaled as "[]"
		Attrs []Attr `json:"attrs,omitempty"`

		// Errors contains wrapped underlying errors.
		// It is optional.
		// If empty, or nil, it will be marshaled as "[]"
		Errors []error `json:"errors,omitempty"`

		// Tags contains categorical labels for error classification.
		// It is optional.
		// If empty, or nil, it will be marshaled as "[]"
		Tags []string `json:"tags,omitempty"`

		// Stack contains the stack trace bytes, typically from a panic recovery.
		// It is optional.
		// If empty, or nil, it will be marshaled as "[]"
		Stack []byte `json:"stack,omitempty"`

		// joined indicates whether this error was created via Join or JoinIf.
		joined bool
	}
)

const (
	// Version is the version of the errors package.
	Version = "0.0.1"
)

//nolint:errcheck // this is for interface assertion
var (
	_ error        = (*StructuredError)(nil)
	_ fmt.Stringer = (*StructuredError)(nil)
)

// New creates a StructuredError with the specified message.
// All other fields (Attrs, Errors, Tags, Stack) are initialized as empty.
func New(message string) *StructuredError {
	return &StructuredError{Message: message}
}

// WithAttrs assigns the given attributes to the receiver and returns it for chaining.
// This method mutates the receiver in place.
func (receiver *StructuredError) WithAttrs(attrs ...Attr) *StructuredError {
	receiver.Attrs = attrs

	return receiver
}

// WithTags prepends the given tags to the receiver and returns it for chaining.
// This method mutates the receiver in place.
func (receiver *StructuredError) WithTags(tags ...string) *StructuredError {
	receiver.Tags = append(tags, receiver.Tags...)

	return receiver
}

// WithErrors assigns the given errors to the receiver and returns it for chaining.
func (receiver *StructuredError) WithErrors(errors ...error) *StructuredError {
    receiver.Errors = errors

	return receiver
}

// WithStack sets the stack trace on the receiver and returns it for chaining.
// This is typically used when recovering from a panic to preserve the stack trace.
// This method mutates the receiver in place.
func (receiver *StructuredError) WithStack(stack []byte) *StructuredError {
	receiver.Stack = stack

	return receiver
}

// PrependErrors adds the given errors before the receiver's existing errors and returns it for chaining.
// This method mutates the receiver in place.
func (receiver *StructuredError) PrependErrors(errors ...error) *StructuredError {
	errs := make([]error, zero, len(errors)+len(receiver.Errors))

	copy(errs, errors)

	receiver.Errors = append(errs, receiver.Errors...)

	return receiver
}

// AppendErrors adds the given errors after the receiver's existing errors and returns it for chaining.
// This method mutates the receiver in place.
func (receiver *StructuredError) AppendErrors(errors ...error) *StructuredError {
	receiver.Errors = append(receiver.Errors, errors...)

	return receiver
}

// Unwrap returns the wrapped errors, implementing the MultiUnwrapper interface.
// This allows StructuredError to work with errors.Is and errors.As.
func (receiver *StructuredError) Unwrap() []error {
	return receiver.Errors
}
