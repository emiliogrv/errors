// Code generated by errors_generator; DO NOT EDIT.
// Generated at 2025-10-19T16:34:35-03:00
// Version 0.0.1

package errors

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	stderrors "errors"
	"strings"
)

type (
	unmarshalJSONError struct {
		Message string                `json:"message,omitempty"`
		Attrs   []Attr                `json:"attrs,omitempty"`
		Errors  []*unmarshalJSONError `json:"errors,omitempty"`
		Tags    []string              `json:"tags,omitempty"`
		Stack   []byte                `json:"stack,omitempty"`
	}
)

var (
	// ErrUnmarshalJSON is returned when unmarshaling fails.
	ErrUnmarshalJSON = New("failed to unmarshal JSON")
)

// fillStructuredError takes a unmarshalJSONError and fills a StructuredError with the unmarshalled data.
func (receiver *unmarshalJSONError) fillStructuredError(structured *StructuredError) {
	structured.Message = receiver.Message
	structured.Attrs = receiver.Attrs
	structured.Tags = receiver.Tags
	structured.Stack = receiver.Stack

	if len(receiver.Errors) > zero {
		structured.Errors = make([]error, zero, len(receiver.Errors))

		for _, err := range receiver.Errors {
			_structured := &StructuredError{}

			err.fillStructuredError(_structured)

			structured.Errors = append(structured.Errors, _structured)
		}
	}
}

// UnmarshalJSON takes a byte slice and unmarshals it into the StructuredError.
// It returns an error if the unmarshaling fails.
//
// The unmarshaled data is stored in the StructuredError.
// If the unmarshaling data is nil, no fields are added to the StructuredError.
func (receiver *StructuredError) UnmarshalJSON(data []byte) error {
	var err unmarshalJSONError

	_err := json.Unmarshal(data, &err)
	if _err != nil {
		return JoinIf(_err, ErrUnmarshalJSON)
	}

	err.fillStructuredError(receiver)

	return nil
}

// MarshalJSON marshals the StructuredError into a byte slice.
// It returns the marshaled byte slice and no error.
//
// The returned []byte will have the following attributes:
//   - Message
//   - Tags
//   - Attrs
//   - Errors
//   - Stack.
//
// The marshaled data is stored in the StructuredError.
// If the marshaled data is nil, no fields are added to the StructuredError.
func (receiver *StructuredError) MarshalJSON() ([]byte, error) {
	var bytesBuffer bytes.Buffer

	receiver.asJSON(&bytesBuffer)

	return bytesBuffer.Bytes(), nil
}

// asJSON marshals the StructuredError into a byte slice.
//
// It returns the marshaled byte slice and no error.
// The marshaled data is stored in the StructuredError.
// If the marshaled data is nil, no fields are added to the StructuredError.
//
// Parameters:
//
//	bytesBuffer - the byte slice to be written to.
//
// Returns: The marshaled byte slice and no error.
func (receiver *StructuredError) asJSON(bytesBuffer *bytes.Buffer) {
	bytesBuffer.WriteString(curlyOpen)
	defer bytesBuffer.WriteString(curlyClose)

	if receiver == nil {
		valueToJSON(bytesBuffer, messageKey, nilValue)

		return
	}

	valueToJSON(bytesBuffer, messageKey, cmpOr(receiver.Message, nilValue))

	if len(receiver.Tags) > zero {
		bytesBuffer.WriteString(comma)
		sliceToJSON(bytesBuffer, tagsKey, receiver.Tags)
	}

	if len(receiver.Attrs) > zero {
		bytesBuffer.WriteString(comma)
		sliceToJSON(bytesBuffer, attrsKey, receiver.Attrs)
	}

	if len(receiver.Errors) > zero {
		target := normalizerTarget{
			errs: make([]error, zero, len(receiver.Errors)),
		}
		normalizeErrors(zero, &target, receiver.Errors...)

		bytesBuffer.WriteString(comma)
		sliceToJSON(bytesBuffer, errorsKey, target.errs)
	}

	if len(receiver.Stack) > zero {
		bytesBuffer.WriteString(comma)

		encoded := base64.StdEncoding.EncodeToString(receiver.Stack)
		valueToJSON(bytesBuffer, stackKey, encoded)
	}
}

// valueToJSON writes a JSON encoded value to the provided bytes.Buffer.
//
// Parameters:
//
//	bytesBuffer - the bytes.Buffer to write to
//	key - the key of the JSON object
//	value - the value to be encoded
//
// Returns: A JSON encoded value is written to the provided bytes.Buffer.
func valueToJSON(bytesBuffer *bytes.Buffer, key, value string) {
	bytesBuffer.WriteString(quote)
	bytesBuffer.WriteString(key)
	bytesBuffer.WriteString(quote)
	bytesBuffer.WriteString(colon)
	bytesBuffer.WriteString(quote)
	bytesBuffer.WriteString(value)
	bytesBuffer.WriteString(quote)
}

// errorToJSON writes a JSON encoded value to the provided bytes.Buffer.
//
// Parameters:
//
//	bytesBuffer - the bytes.Buffer to write to
//	err - the error to be encoded
//
// The function writes a JSON object to the provided bytes.Buffer.
// If the error is nil, the function writes a JSON object with the key "message" and the value "nil".
// If the error is a StructuredError, the function writes a JSON object with the same fields as the StructuredError.
// If the error is not a StructuredError, the function writes a JSON object with the key "message"
// and the value of the error's Error() method.
//
// Returns: A JSON encoded value is written to the provided bytes.Buffer.
func errorToJSON(bytesBuffer *bytes.Buffer, err error) {
	var value *StructuredError
	switch {
	case err == nil:
		bytesBuffer.WriteString(curlyOpen)
		valueToJSON(bytesBuffer, messageKey, nilValue)
		bytesBuffer.WriteString(curlyClose)
	case stderrors.As(err, &value):
		value.asJSON(bytesBuffer)
	default:
		errStr := strings.TrimSpace(err.Error())

		bytesBuffer.WriteString(curlyOpen)
		valueToJSON(bytesBuffer, messageKey, cmpOr(errStr, nilValue))
		bytesBuffer.WriteString(curlyClose)
	}
}

// sliceToJSON writes a JSON encoded value to the provided bytes.Buffer.
//
// Parameters:
//
//	bytesBuffer - the bytes.Buffer to write to
//	key - the key of the JSON object
//	slice - the slice of values to be encoded
//
// Returns: A JSON encoded value is written to the provided bytes.Buffer.
func sliceToJSON[T any](bytesBuffer *bytes.Buffer, key string, slice []T) {
	bytesBuffer.WriteString(quote)
	bytesBuffer.WriteString(key)
	bytesBuffer.WriteString(quote)
	bytesBuffer.WriteString(colon)

	if len(slice) == zero {
		bytesBuffer.WriteString(bracketOpen)
		bytesBuffer.WriteString(bracketClose)

		return
	}

	switch values := any(slice).(type) {
	case []error:
		bytesBuffer.WriteString(bracketOpen)

		for index, value := range values {
			if index > zero {
				bytesBuffer.WriteString(comma)
			}

			errorToJSON(bytesBuffer, value)
		}

		bytesBuffer.WriteString(bracketClose)
	default:
		arr, err := json.Marshal(slice)
		if err != nil {
			bytesBuffer.WriteString(bracketOpen)
			bytesBuffer.WriteString(err.Error())
			bytesBuffer.WriteString(bracketClose)

			return
		}

		bytesBuffer.Write(arr)
	}
}
