// Code generated by errors_generator; DO NOT EDIT.
// Generated at 2025-10-19T16:34:35-03:00
// Version 0.0.1

package errors

import (
	stderrors "errors"
)

//nolint:gochecknoglobals,varnamelen // these are just aliases for the std errors package
var (
	// Unwrap returns the result of calling the Unwrap method on err, if err's
	// type contains an Unwrap method returning error.
	// Otherwise, Unwrap returns nil.
	//
	// Unwrap only calls a method of the form "Unwrap() error".
	// In particular Unwrap does not unwrap errors returned by [Join] or [JoinIf].
	Unwrap = stderrors.Unwrap

	// Is reports whether any error in err's tree matches target.
	//
	// The tree consists of err itself, followed by the errors obtained by repeatedly
	// calling its Unwrap() error or Unwrap() []error method. When err wraps multiple
	// errors, Is examines err followed by a depth-first traversal of its children.
	//
	// An error is considered to match a target if it is equal to that target or if
	// it implements a method Is(error) bool such that Is(target) returns true.
	//
	// An error type might provide an Is method so it can be treated as equivalent
	// to an existing error. For example, if MyError defines
	//
	//	func (m MyError) Is(target error) bool { return target == fs.ErrExist }
	//
	// then Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is] for
	// an example in the standard library. An Is method should only shallowly
	// compare err and the target and not call [Unwrap] on either.
	Is = stderrors.Is

	// As finds the first error in err's tree that matches target, and if one is found, sets
	// target to that error value and returns true. Otherwise, it returns false.
	//
	// The tree consists of err itself, followed by the errors obtained by repeatedly
	// calling its Unwrap() error or Unwrap() []error method. When err wraps multiple
	// errors, As examines err followed by a depth-first traversal of its children.
	//
	// An error matches target if the error's concrete value is assignable to the value
	// pointed to by target, or if the error has a method As(any) bool such that
	// As(target) returns true. In the latter case, the As method is responsible for
	// setting target.
	//
	// An error type might provide an As method so it can be treated as if it were a
	// different error type.
	//
	// As panics if target is not a non-nil pointer to either a type that implements
	// error, or to any interface type.
	As = stderrors.As
)

// Is reports whether any error in StructuredError's chain matches target.
// It first checks if the current error matches the target, then checks each error in the Errors slice.
func (receiver *StructuredError) Is(target error) bool {
	if receiver == target {
		return true
	}

	// Handle nil receiver
	if receiver == nil {
		return false
	}

	// Check each error in the chain
	for _, err := range receiver.Errors {
		if Is(err, target) {
			return true
		}
	}

	return false
}

// As finds the first error in StructuredError's chain that matches the target type,
// and if one is found, sets the target to its value and returns true.
func (receiver *StructuredError) As(target any) bool {
	if receiver == nil {
		return false
	}

	// Try to match the receiver itself first
	if receiver == target {
		return true
	}

	if as, ok := target.(*StructuredError); ok {
		*as = *receiver

		return true
	}

	// Check each error in the chain
	for _, err := range receiver.Errors {
		if As(err, target) {
			return true
		}
	}

	return false
}
