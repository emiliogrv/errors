// Code generated by errors_generator; DO NOT EDIT.
// Generated at 2025-10-19T16:34:35-03:00
// Version 0.0.1

package errors

import (
	stderrors "errors"
	"strings"
)

// AsMap marshals the StructuredError into a map[string]any
// If the receiver is nil, it adds a single field to the map[string]any with the key "message"
// and the value nilValue.
//
// Otherwise, it will have the following attributes:
//   - Message
//   - Tags
//   - Attrs
//   - Errors
//   - Stack.
func (receiver *StructuredError) AsMap() map[string]any {
	fields := make(map[string]any)

	receiver.asMap(fields)

	return fields
}

// asMap is the actual implementation for AsMap.
func (receiver *StructuredError) asMap(fields map[string]any) {
	if receiver == nil {
		fields[messageKey] = nilValue

		return
	}

	fields[messageKey] = cmpOr(receiver.Message, nilValue)

	if len(receiver.Tags) > zero {
		sliceToMap(fields, tagsKey, receiver.Tags)
	}

	if len(receiver.Attrs) > zero {
		sliceToMap(fields, attrsKey, receiver.Attrs)
	}

	if len(receiver.Errors) > zero {
		target := normalizerTarget{
			errs: make([]error, zero, len(receiver.Errors)),
		}
		normalizeErrors(zero, &target, receiver.Errors...)

		sliceToMap(fields, errorsKey, target.errs)
	}

	if len(receiver.Stack) > zero {
		sliceToMap(fields, stackKey, strings.Split(string(receiver.Stack), newLine))
	}
}

// AsMap marshals the Attr into a map[string]any
// If the receiver is nil, it adds a single field to the map[string]any with the key "nil" and the value nilValue.
//
// Otherwise, it will have a single attribute with the key receiver.Key and the value receiver.Value.
func (receiver *Attr) AsMap() map[string]any {
	fields := make(map[string]any, one)

	receiver.asMap(fields)

	return fields
}

// asMap is the actual implementation for AsMap.
//
//nolint:forcetypeassert,errcheck // XXXType helpers avoid using reflection
func (receiver *Attr) asMap(fields map[string]any) {
	if receiver == nil {
		fields[nilValue] = nilValue

		return
	}

	switch receiver.Type { //nolint:exhaustive // just strings need specific assert
	case StringsType:
		sliceToMap(fields, receiver.Key, receiver.Value.([]string))
	default:
		fields[receiver.Key] = receiver.Value
	}
}

// errorToMap marshals an error into the given map[string]any.
//
// If the error is nil, it adds a single field to the map[string]any with the key "message"
// and the value nilValue.
//
// If the error is a *StructuredError, it marshals the *StructuredError into the map[string]any.
//
// If the error is not a *StructuredError, it adds a single field to the map[string]any with the key "message"
// and the value of the error's Error() method, or nilValue if the error is nil.
func errorToMap(fields map[string]any, err error) {
	var value *StructuredError
	switch {
	case err == nil:
		fields[messageKey] = nilValue
	case stderrors.As(err, &value):
		value.asMap(fields)
	default:
		errStr := strings.TrimSpace(err.Error())
		fields[messageKey] = cmpOr(errStr, nilValue)
	}
}

// sliceToMap converts a slice of any type to a map[string]any value.
func sliceToMap[T any](fields map[string]any, key string, slice []T) {
	if len(slice) == zero {
		fields[key] = []struct{}{}

		return
	}

	switch values := any(slice).(type) {
	case []Attr:
		attrs := make(map[string]any, len(values))
		for _, attr := range values {
			attr.asMap(attrs)
		}

		fields[key] = attrs
	case []error:
		errs := make([]map[string]any, zero, len(values))
		for index, err := range values {
			errs = append(errs, make(map[string]any))

			errorToMap(errs[index], err)
		}

		fields[key] = errs
	case []string:
		result := make([]string, zero, len(values))

		for _, value := range values {
			result = append(result, strings.TrimSpace(value))
		}

		fields[key] = result
	default:
		fields[key] = slice
	}
}
