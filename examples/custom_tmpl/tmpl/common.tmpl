{{if .WithGenHeader -}}
// Code generated by errors_generator; DO NOT EDIT.
// Generated at {{.Date}}
// Version {{.Version}}

{{end -}}
package {{.PackageName}}

import (
	stderrors "errors"
)

type (
	normalizerTarget struct {
		errs []error
	}
)

const (
	messageKey       = "message"
	attrsKey         = "attrs"
	errorsKey        = "errors"
	tagsKey          = "tags"
	stackKey         = "stack"
	depthKey         = "depth"
	nilValue         = "!NILVALUE"
	equals           = "="
	colon            = ":"
	quote            = `"`
	newLine          = "\n"
	tab              = "\t"
	comma            = ","
	curlyOpen        = "{"
	curlyClose       = "}"
	bracketOpen      = "["
	bracketClose     = "]"
	parenthesisOpen  = "("
	parenthesisClose = ")"

	maxDepthExceeded = "max depth exceeded"

	zero      = 0
	one       = 1
	ten       = 10
	sixtyFour = 64

	verboseFormat = "%+v"
)

var (
	maxDepthMarshal = 10 //nolint:gochecknoglobals // needed to avoid use of specific instance of StructuredError

	// ErrDepthExceeded is the error returned when the StructuredError is marshaled to a depth
	// greater than MaxDepthMarshal.
	ErrDepthExceeded = New(maxDepthExceeded).WithAttrs(Int(depthKey, maxDepthMarshal))
)

// MaxDepthMarshal returns the maximum depth to which the StructuredError
// can be marshaled. If the StructuredError is marshaled to a depth
// greater than MaxDepthMarshal, it will be truncated at the specified
// depth during marshaling.
//
// The default value of MaxDepthMarshal is math.MaxInt - 1, which
// means that the StructuredError can be marshaled to any valid depth.
//
// If MaxDepthMarshal is set to a value less than or equal to 0,
// the StructuredError cannot be marshaled.
//
// The maximum depth to which the StructuredError can be marshaled is
// limited by the amount of memory available to the program.
//
// The user can set MaxDepthMarshal to a value greater than the default
// value to increase the maximum depth to which the StructuredError can be
// marshaled. However, doing so increases the risk of the program
// panicking if the StructuredError is too large to be marshaled.
//
// The user can also set MaxDepthMarshal to a value less than the default
// value to decrease the maximum depth to which the StructuredError can be
// marshaled. However, doing so increases the risk of the
// StructuredError being truncated during marshaling.
func MaxDepthMarshal() int {
	return maxDepthMarshal
}

// SetMaxDepthMarshal sets the maximum depth to which the StructuredError
// can be marshaled. If the StructuredError is marshaled to a depth
// greater than the specified depth, it will be truncated at the specified
// depth during marshaling.
//
// The specified depth should be a positive integer.
//
// If the specified depth is less than or equal to 0, the
// StructuredError cannot be marshaled.
//
// The maximum depth to which the StructuredError can be marshaled is
// limited by the amount of memory available to the program.
//
// The user can set the maximum depth to which the StructuredError can be
// marshaled by calling SetMaxDepthMarshal with a positive integer value.
//
// SetMaxDepthMarshal is not thread-safe. It should be called before any
// StructuredError is marshaled.
func SetMaxDepthMarshal(depth int) {
	maxDepthMarshal = depth

	err := New(maxDepthExceeded).WithAttrs(Int(depthKey, depth))
	*ErrDepthExceeded = *err
}

// add appends the given errors to the receiver's errors.
//
// The given errors are appended to the end of the receiver's errors.
// If the given errors are empty, the receiver's errors are not modified.
//
// The maximum depth to which the StructuredError can be marshaled is
// limited by the amount of memory available to the program.
//
// The user can set the maximum depth to which the StructuredError can be
// marshaled by calling SetMaxDepthMarshal with a positive integer value.
func (receiver *normalizerTarget) add(err ...error) {
	receiver.errs = append(receiver.errs, err...)
}

// normalizeErrors takes a depth, a target, and a variable number of errors
// and normalizes the given errors.
//
// The given errors are normalized by recursively calling normalizeErrors
// until the maximum depth is reached. If the maximum depth is reached,
// ErrDepthExceeded is added to the receiver's errors.
//
// The given errors are normalized by splitting them into individual
// StructuredError, unwrapping the StructuredError, and adding the unwrapped
// errors to the receiver's errors.
//
// The maximum depth to which the StructuredError can be marshaled is
// limited by the amount of memory available to the program.
//
// The user can set the maximum depth to which the StructuredError can be
// marshaled by calling SetMaxDepthMarshal with a positive integer value.
func normalizeErrors(depth int, target *normalizerTarget, errs ...error) {
	if depth > maxDepthMarshal {
		target.add(ErrDepthExceeded)

		return
	}

	_depth := depth + one

	for _, err := range errs {
		if err == nil {
			target.add(err)

			continue
		}

		{
			var (
				_err  *StructuredError
				_err1 SingleUnwrapper
				_err2 MultiUnwrapper
			)

			switch {
			case stderrors.As(err, &_err):
				if _err == nil {
					target.add(err)

					continue
				}

				if _err.joined {
					normalizeErrors(depth, target, _err.Errors...)

					continue
				}

				if len(_err.Errors) == zero {
					target.add(err)

					continue
				}

				_target := normalizerTarget{errs: make([]error, zero, len(_err.Errors))}
				normalizeErrors(_depth, &_target, _err.Errors...)
				target.add(
					&StructuredError{
						Message: _err.Message,
						Attrs:   _err.Attrs,
						Errors:  _target.errs,
						Tags:    _err.Tags,
						Stack:   _err.Stack,
					},
				)
			case stderrors.As(err, &_err1):
				normalizeErrors(depth, target, _err1.Unwrap())
			case stderrors.As(err, &_err2):
				normalizeErrors(depth, target, _err2.Unwrap()...)
			default:
				target.add(err)
			}
		}
	}
}

// cmpOr returns the first of its arguments that is not equal to the zero value.
// If no argument is non-zero, it returns the zero value.
// This is here since cmp.Or is not available in Go 1.18.
//nolint:ireturn // this is a helper function
func cmpOr[T comparable](vals ...T) T {
	var def T
	for _, val := range vals {
		if val != def {
			return val
		}
	}

	return def
}
